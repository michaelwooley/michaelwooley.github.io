<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Michael Wooley&#39;s Homepage</title>
    <link>https://michaelwooley.github.io/</link>
    <description>Recent content on Michael Wooley&#39;s Homepage</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 22 Oct 2018 18:28:59 -0400</lastBuildDate>
    <atom:link href="https://michaelwooley.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>A Time- and Memory-Efficient Solution to $\text{cholesky}\left[A\otimes B\right]\varepsilon$</title>
      <link>https://michaelwooley.github.io/posts/solve-chol-kron-ab-e/</link>
      <pubDate>Mon, 22 Oct 2018 18:28:59 -0400</pubDate>
      
      <guid>https://michaelwooley.github.io/posts/solve-chol-kron-ab-e/</guid>
      <description>

&lt;p&gt;This post discusses an efficient solution to $\text{cholesky}\left[A\otimes B\right]\varepsilon$, where $A$ and $B$ are real, symmetric, positive definite matrices of while $\varepsilon$ is an appropriately-sized vector. Why would anyone ever want to compute this thing? Basically, an expression like this is going to pop up if you want to sample from a multivariate normal distribution with covariance matrix $A\otimes B$.&lt;/p&gt;

&lt;figure&gt;
&lt;label for=&#34;size-of0&#34; class=&#34;margin-toggle&#34;&gt;&amp;#8853;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;size-of0&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;marginnote&#34;&gt;
    &lt;img src=&#34;https://michaelwooley.github.io/posts/solve-chol-kron-ab-e/media/chol_kron_ab_size.svg&#34;&gt;
    &lt;span style=&#39;font-weight:bold;&#39; id=&#39;ab-size&#39;&gt;Figure 1.&lt;/span&gt; We&amp;rsquo;ll quickly run into memory errors if we blindly compute $A\otimes B$. The projected matrix size in gigabytes assumes a 64-bit float.
&lt;/span&gt;
&lt;/figure&gt;


&lt;p&gt;For me, this expression arose as a bottleneck in a project that I&amp;rsquo;m working on that involves a Bayesian VAR with a Normal-Inverse-Wishart prior. What&amp;rsquo;s wrong with using regular NumPy to compute &lt;code&gt;np.linalg.cholesky(np.kron(A, B)).dot(e)&lt;/code&gt;? This matrix gets very big very fast. You can see this in &lt;a href=&#34;#ab-size&#34;&gt;Figure 1&lt;/a&gt;, which considers the BVAR case with a set number of lags $p$ and $n$ variables per period. In the normal-inverse-wishart case the posterior covariance matrix has size $n(n\cdot p+1)\times n(n\cdot p+1)$. The right figure says that we need about 10,000 &lt;em&gt;gigabytes&lt;/em&gt; to compute $A\otimes B$ when $n=200$ and $lags=13$. I want to be able to accommodate specifications of this magnitude. In order to do so, though, I&amp;rsquo;m going to need to find an alternative to &lt;code&gt;np.linalg.cholesky(np.kron(A, B)).dot(e)&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;a-solution:a1555d59ae587cdf813d543d9fa6acc1&#34;&gt;A Solution&lt;/h2&gt;

&lt;p&gt;The key to solving this problem is to avoid explicitly computing $A \otimes B$. This can be done by observing that&lt;/p&gt;

&lt;p&gt;$$\text{cholesky}\left[ A\otimes B\right] = \text{cholesky}[A]\otimes \text{cholesky}[B].$$&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s prove this. Recall that the Cholesky decomposition of a real, symmetric, positive definite matrix $X$ is a lower-triangular matrix $L$ such that:&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;Cholesky decompositions can exist in other cases but we are only interested in this case. Note also that a Cholesky decomposition always exists when a matrix satisfies the properties on $X$&lt;/span&gt; 

$$X = LL^{\prime}$$
Now define $L_A$ and $L_B$ so that $A = L_A L_A^{\prime}$ and $B = L_B L_B^{\prime}$. Additionally define $L_C := L_A \otimes L_B$. Notice that $L_C$ is also lower-triangular and&amp;ndash;since $L_A$ and $L_B$ have real and postive diagonal entries&amp;ndash;so too does $L_C$. Consider the following:&lt;/p&gt;

&lt;p&gt;\begin{align}
L_C L_C^{\prime} &amp;amp; = (L_A \otimes L_B)(L_A \otimes L_B)^{\prime} \newline
&amp;amp; =(L_A \otimes L_B)(L_A^{\prime} \otimes L_B^{\prime})  \newline
&amp;amp; =(L_A L_A^{\prime} \otimes L_B L_B^{\prime}) \newline
&amp;amp; =A\otimes B
\end{align}&lt;/p&gt;

&lt;p&gt;From this we see that $L_C$ is the Cholesky decomposition of $A\otimes B$.&lt;/p&gt;

&lt;p&gt;What does this fact give us? Two things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;We avoid explicitly computing the full kronecker product.

&lt;ul&gt;
&lt;li&gt;Clearly, this saves on memory.&lt;/li&gt;
&lt;li&gt;Moreover, since the matrices that we &lt;em&gt;are&lt;/em&gt; multiplying are lower-triangular, we can skip multiplicative terms where an input is known to be zero.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Computing two (relatively small) choleskies is cheaper than computing the cholesky of $A\otimes B$.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Here is some pseudo-code for the solution to $\text{cholesky}\left[A\otimes B\right]\varepsilon$:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;chol_kron_ab_e&lt;/span&gt;(A: FMATRIX, B: FMATRIX, e: FVECTOR) &lt;span style=&#34;color: #666666&#34;&gt;-&amp;gt;&lt;/span&gt; FVECTOR:
  &lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;&amp;quot;&amp;quot;&amp;quot;Solution to `cholesky[kron[A, B]] * e`.&lt;/span&gt;
&lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;  Args:&lt;/span&gt;
&lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;      A (FMATRIX): Real, Symmetric, Positive Definite Matrix of size [mA, mA]&lt;/span&gt;
&lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;      B (FMATRIX): Real, Symmetric, Positive Definite Matrix of size [mB, mB]&lt;/span&gt;
&lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;      e (FVECTOR): Vector of shape [mA * mB, 1]&lt;/span&gt;
&lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;  Returns:&lt;/span&gt;
&lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;      FVECTOR: Vector of shape [mA * mB, 1] solution to `cholesky[kron[A, B]] * e`&lt;/span&gt;
&lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;  &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
  mA &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; A&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;shape[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]
  mB &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; B&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;shape[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]
  L_a &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; cholesky(A)
  L_b &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; cholesky(B)

  out &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;zeros((mA &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; mB))

  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; ii &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;range&lt;/span&gt;(mA):
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; jj &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;range&lt;/span&gt;(ii &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;):
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; hh &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;range&lt;/span&gt;(mB):
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; kk &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;range&lt;/span&gt;(hh &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;):
          out[mB &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; ii &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; hh] &lt;span style=&#34;color: #666666&#34;&gt;+=&lt;/span&gt; L_a[ii, jj] &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; L_b[hh, kk] &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; e[mB &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; jj &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; kk]

  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; out
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Obviously, this would be pretty slow to run in standard python. In the tested implementation I used &lt;a href=&#34;https://numba.pydata.org/&#34;&gt;Numba&lt;/a&gt;, which can do explicit loops efficiently.&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;For the sake of comparison, all of the test functions below are compiled with Numba.&lt;/span&gt; 
&lt;/p&gt;

&lt;h2 id=&#34;evaluation:a1555d59ae587cdf813d543d9fa6acc1&#34;&gt;Evaluation&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s see how well this thing works. Throughout, we&amp;rsquo;ll use a numba version of &lt;code&gt;np.linalg.cholesky(np.kron(A, B)).dot(e)&lt;/code&gt; as a benchmark.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;#time-to-compute-inner&#34;&gt;Figure 2&lt;/a&gt; provides some information on time-to-compute. I&amp;rsquo;ve kept the size of the matrices relatively small so that the benchmark can be computed.&lt;/p&gt;

&lt;figure&gt;
&lt;label for=&#34;time-to-compute&#34; class=&#34;margin-toggle&#34;&gt;&amp;#8853;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;time-to-compute&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;img src=&#34;https://michaelwooley.github.io/posts/solve-chol-kron-ab-e/media/chol_kron_time_usage.svg&#34;&gt;
&lt;span class=&#34;marginnote&#34;&gt;&lt;span style=&#39;font-weight:bold;&#39; id=&#39;time-to-compute-inner&#39;&gt;Figure 2.&lt;/span&gt; The proposed algorithm (&amp;ldquo;Loop&amp;rdquo;) provides a considerable speed-up over the benchmark and is pretty fast in absolute terms.&lt;/span&gt;
&lt;/figure&gt;


&lt;p&gt;From the left figure we see that the proposed algorithm quickly achieves a speed-up at all matrix sizes. As the size of the matrices increase the speed-up increases at a more-or-less linear rate.&lt;/p&gt;

&lt;p&gt;The right sub-figure plots the absolute time-to-compute for the proposed algorithm in seconds. Not surprisingly, this relationship is convex at all lags. However, in absolute terms it is still pretty fast.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;#chol-kron-memory-usage&#34;&gt;Figure 3&lt;/a&gt; compares the memory requirements of the two algorithms. Due to the long time-to-compute when calculating memory usage for the benchmark case, we only did this at a few values. The memory usage statistic presented here is the maximum memory usage required by the process, as computed by the command &lt;a href=&#34;https://github.com/pythonprofilers/memory_profiler&#34;&gt;&lt;code&gt;memory_profiler.memory_usage&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;
&lt;label for=&#34;memory-usage-label&#34; class=&#34;margin-toggle&#34;&gt;&amp;#8853;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;memory-usage-label&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;img src=&#34;https://michaelwooley.github.io/posts/solve-chol-kron-ab-e/media/chol_kron_memory_usage.svg&#34;&gt;
&lt;span class=&#34;marginnote&#34;&gt;&lt;span style=&#39;font-weight:bold;&#39; id=&#39;chol-kron-memory-usage&#39;&gt;Figure 3.&lt;/span&gt; Relative and Absolute Memory Usage.&lt;/span&gt;
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;The proposed algorithm is pretty memory-efficient. With 42 variables the NumPy method already requires about 8.2 gigs of memory. Most people don&amp;rsquo;t have that kind of memory to spare! On the other hand, memory consumption of the alternative method grows at a modest (though convex) rate.&lt;/p&gt;

&lt;p&gt;Finally, I tested the proposed algorithm for large-dimensional cases.&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;The benchmark is skipped here because I don&amp;rsquo;t have enough memory to do this sort of comparison.&lt;/span&gt; 
 The results are displayed in &lt;a href=&#34;#big-mat&#34;&gt;Figure 4&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;
&lt;label for=&#34;big-mat-outer&#34; class=&#34;margin-toggle&#34;&gt;&amp;#8853;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;big-mat-outer&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;img src=&#34;https://michaelwooley.github.io/posts/solve-chol-kron-ab-e/media/chol_kron_big.svg&#34;&gt;
&lt;span class=&#34;marginnote&#34;&gt;&lt;span style=&#39;font-weight:bold;&#39; id=&#39;big-mat&#39;&gt;Figure 4.&lt;/span&gt; Time-to-compute and memory usage for proposed algorithm (&amp;ldquo;loop&amp;rdquo;) only.&lt;/span&gt;
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;First, the good: memory usage continues to climb &lt;em&gt;very&lt;/em&gt; slowly despite a huge increase in the size of matrices involved. Second, the okay: time-to-run is non-trivial at higher $n$. It also seems to pick up around $n=125$ for some reason. If you want to do sampling with this thing you better plan ahead.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:a1555d59ae587cdf813d543d9fa6acc1&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;m a little bit disappointed that I couldn&amp;rsquo;t keep the time down a bit more for the larger matrices. If I had a bit more time I&amp;rsquo;d investigate pure-c versions of this procedure to see how low it can go. If you have the time and want to try that, feel free to build on my results, which I&amp;rsquo;ve posted as a &lt;a href=&#34;https://gist.github.com/michaelwooley/93892fd8a2727211e037b5b922185769&#34;&gt;gist&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>(Really) Tight Bounding Boxes</title>
      <link>https://michaelwooley.github.io/posts/tight-bb-1/</link>
      <pubDate>Fri, 22 Sep 2017 20:49:59 -0400</pubDate>
      
      <guid>https://michaelwooley.github.io/posts/tight-bb-1/</guid>
      <description>

&lt;p&gt;I&amp;rsquo;ve created a simple method to determine &lt;em&gt;precise&lt;/em&gt; bounding boxes for characters and  text elements within an SVG. Why would this be necessary? Can&amp;rsquo;t we just get the bounding box for an element by calling &lt;code&gt;node.getBBox()&lt;/code&gt;? It depends on how much precision you need. For text characters and strings this method will assign the same bounding box for every character. So, for example, the bounding boxes for &amp;ldquo;a&amp;rdquo;, &amp;ldquo;g&amp;rdquo;, and &amp;ldquo;f&amp;rdquo; will all be the same. For a lot of applications this will do. However, if you need to know exactly where a character is located it would be preferable to have a bit more precision.&lt;/p&gt;

&lt;p&gt;Here is a sample application that demonstrates the tight bounding box:&lt;/p&gt;

&lt;figure&gt;
&lt;label for=&#34;main-sample&#34; class=&#34;margin-toggle&#34;&gt;&amp;#8853;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;main-sample&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;marginnote&#34;&gt;The purple area is the bounding box from calling &lt;code&gt;node.getBBox()&lt;/code&gt; while the blue area is the tight bounding box.&lt;/span&gt;
&lt;div class=&#34;sample-div&#34;&gt;&lt;/div&gt;
&lt;/figure&gt;


&lt;p&gt;The basic strategy will be to &amp;ldquo;copy&amp;rdquo; the SVG &lt;code&gt;&amp;lt;text&amp;gt;&lt;/code&gt; element onto an HTML &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; element. We&amp;rsquo;ll then back out the bounding box by analyzing the canvas RGBA array.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve implemented this procedure as a prototype of &lt;code&gt;d3.selection&lt;/code&gt;. This means that we can find the bounding box by calling, e.g., &lt;code&gt;d3.select(&#39;text&#39;).getTightBBox()&lt;/code&gt;. This call attaches an object property &lt;code&gt;tBB&lt;/code&gt; to the to the node of the element (e.g. &lt;code&gt;d3.select(&#39;text&#39;).node().tBB&lt;/code&gt;). This ensures that the method only has to be called once.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m going to start out by giving a detailed qualitative overview of what needs to happen and point out some problem areas. Then I&amp;rsquo;ll run through the actual code, which&amp;ndash;due to the problem areas&amp;ndash;isn&amp;rsquo;t very pretty at the moment.&lt;/p&gt;

&lt;h2 id=&#34;outline-and-preview-of-hiccups:1956d6c4eb3b8644416373fe86aead14&#34;&gt;Outline and Preview of Hiccups&lt;/h2&gt;

&lt;p&gt;Suppose that we have a white image with the character &amp;ldquo;1&amp;rdquo; (in black) in the middle. We want to draw a tight bounding box around the character. If we have a &amp;ldquo;usual&amp;rdquo; image format (e.g. JPEG, png) we could extract the pixels from the image as a 4D array of RGBA values. We could then loop through each of these pixels and search for the locations where the color changes. Once we know the location of all of the border pixels we can set the minimal &lt;code&gt;x&lt;/code&gt; (horizontal) coordinate of the box by finding the least column in which a border pixel occurs. We can do something similar to find the maximal &lt;code&gt;x&lt;/code&gt;, minimal &lt;code&gt;y&lt;/code&gt; (vertical), and maximal &lt;code&gt;y&lt;/code&gt; coordinates of the box.&lt;/p&gt;

&lt;p&gt;What makes this strategy viable? First, the input image was super-simple: a black character on a white background. There was nothing else on the image that could have been confused for the character.&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;Obvious example: there wasn&amp;rsquo;t a picture of a smiley face to the side. Maybe less-obvious: it wouldn&amp;rsquo;t work if the image was scanned in and there was some weird &amp;ldquo;scan marks&amp;rdquo; on the image.&lt;/span&gt; 
 Second, we could get a pixel array that represented the image. While this might seem trivial, it will be fairly important in future developments.&lt;/p&gt;

&lt;h3 id=&#34;pixelated-svgs:1956d6c4eb3b8644416373fe86aead14&#34;&gt;&amp;ldquo;Pixelated&amp;rdquo; SVGs&lt;/h3&gt;

&lt;p&gt;In our application the bounding box will be made for text in an SVG image. The problem with SVGs is that they don&amp;rsquo;t have pixel representations.&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;Now would be a good time to state that I&amp;rsquo;m not an expert on SVGs. Apologies if some of my terminology and/or statements are off.&lt;/span&gt; 
 So are we dead in the water? Not exactly. One thing that we can try to do is &amp;ldquo;draw&amp;rdquo; the SVG element on an HTML canvas, which does have a pixel representation.&lt;/p&gt;

&lt;p&gt;How do we convert an SVG element to a canvas? The method that I&amp;rsquo;m going to use here only works for SVG &lt;code&gt;&amp;lt;text&amp;gt;&lt;/code&gt; elements. However, it works for a wider variety of cases than other methods that I&amp;rsquo;ve attempted.&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;One general method that looked promising involved serializing the SVG element to a string then drawing it on a canvas. I found that this method wasn&amp;rsquo;t working well on non-standard fonts. It is also somewhat messy because it relies on callbacks. &lt;a href=&#34;https://stackoverflow.com/questions/27230293/how-to-convert-svg-to-png-using-html5-canvas-javascript-jquery-and-save-on-serve/33227005#33227005&#34;&gt;See this answer from Stack Overflow&lt;/a&gt; for more info.&lt;/span&gt; 
 In short, we&amp;rsquo;re going to manually &amp;ldquo;re-make&amp;rdquo; the SVG element on the canvas by drawing text on the canvas that has the same styling and position properties as the text on the SVG.&lt;/p&gt;

&lt;h3 id=&#34;issues-with-canvas:1956d6c4eb3b8644416373fe86aead14&#34;&gt;Issues With Canvas&lt;/h3&gt;

&lt;p&gt;Two issues arise when we try duplicate the text using &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The first is that&amp;ndash;relative to the SVG&amp;ndash;the canvas will look pretty grainy (because it is grainy). This will be problematic because, if we find the bounding box of a grainy image, the bounding box will be off by a tad when we try to apply the bounding box to the smooth SVG text. To get around this we&amp;rsquo;ll scale up the drawing of the text element on the canvas. With this enlarged image we&amp;rsquo;ll find a bounding box, which will be too large for the original image. However, we can simply scale the bounding box coordinates back down to the original image, which will mean that the coordinates will be floats rather than integers. The bounding box will then fit onto the SVG text much more tightly.&lt;/p&gt;

&lt;p&gt;The second problem has to do with fonts. Suppose that you want to use a wacky font from &lt;a href=&#34;https://fonts.google.com/&#34;&gt;Google Fonts&lt;/a&gt;. You can draw text in a canvas using one of these fonts. However, these fonts need to be loaded and that can take some time. If your application involves finding tight bounding boxes at the time the page is loading then the bounding box code may execute before the font is loaded. This is problematic because the machine will revert to the default font if the requested font isn&amp;rsquo;t found. Since the bounding box is fit on a font that is different from the visible SVG text, the bounding box will be off.&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;Since the font of SVG elements are set via the &lt;code&gt;style&lt;/code&gt; attribute or CSS, they will adjust their fonts once the specified font is loaded.&lt;/span&gt; 
 When this is an issue it will be necessary to ensure that the method is called only after the font is loaded.&lt;/p&gt;

&lt;h2 id=&#34;the-code:1956d6c4eb3b8644416373fe86aead14&#34;&gt;The Code&lt;/h2&gt;

&lt;p&gt;The main method is as follows:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;d3.selection.prototype.getTightBBox &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; () {

  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; self &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;;

  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Check to ensure that it is a text element&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (self.node().tagName.toLowerCase() &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;text&amp;#39;&lt;/span&gt;) {
    console.error(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;d3.selection.getTightBBox can only accommodate SVG &amp;lt;text&amp;gt; elements.&amp;#39;&lt;/span&gt;);
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt;;
  }

  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Scaling factor&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; k &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;10&lt;/span&gt;, c &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;4&lt;/span&gt;;
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Get parent SVG (how to throw good error?)&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; svgText &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; self._groups[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;][&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;].ownerSVGElement;
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Check in on fonts to ensure all is okay.&lt;/span&gt;
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Do this before setting the loose bounding box because may change&lt;/span&gt;
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// the font.&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; targetFont &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; k &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;parseFloat&lt;/span&gt;(self.style(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;font-size&amp;#39;&lt;/span&gt;)) &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;px &amp;#39;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; self.style(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;font-family&amp;#39;&lt;/span&gt;);
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color: #666666&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color: #008000&#34;&gt;document&lt;/span&gt;.fonts.check(targetFont)) {
    targetFont &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; k &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;parseFloat&lt;/span&gt;(self.style(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;font-size&amp;#39;&lt;/span&gt;)) &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;px sans&amp;#39;&lt;/span&gt;;
    self.style(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;font-family&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;sans&amp;#39;&lt;/span&gt;);
    console.warn(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;d3.selection.getTightBBox: Font family &amp;#39;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; targetFont &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39; not found. Setting to &amp;quot;sans&amp;quot; font and proceeding.&amp;#39;&lt;/span&gt;);
  }
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Loose Bounding Box&lt;/span&gt;
  lBB &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; self.node().getBBox();
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Make a canvas to search for element&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; canvas &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; d3.select(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;body&amp;#39;&lt;/span&gt;)
    .append(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;canvas&amp;#39;&lt;/span&gt;)
    .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;height&amp;#39;&lt;/span&gt;, k &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; svgText.clientHeight)
    .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;width&amp;#39;&lt;/span&gt;, k &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; svgText.clientWidth)
    .style(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;display&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;none&amp;#39;&lt;/span&gt;)
    .node();
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Get and set the context based on others&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; ctx &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; canvas.getContext(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;2d&amp;#39;&lt;/span&gt;);
  ctx.font &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; targetFont;
  ctx.fillText(self.text(), k &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;parseFloat&lt;/span&gt;(self.attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;x&amp;#39;&lt;/span&gt;)), k &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;parseFloat&lt;/span&gt;(self.attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;y&amp;#39;&lt;/span&gt;)));
  
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Break the image into pixels&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; imgData &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; ctx.getImageData(k &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; lBB.x, k &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; lBB.y, k &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; lBB.width, k &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; lBB.height);
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Use the image data to get a tight bounding box&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; bb &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; tightBBox(imgData);
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Undo scaling to get back to svg&lt;/span&gt;
  bb.x &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; (bb.x &lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt; k) &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; lBB.x;
  bb.y &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; (bb.y &lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt; k) &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; lBB.y;
  bb.width &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; bb.width &lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt; k;
  bb.height &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; bb.height &lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt; k;

  self.node().tBB &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; bb;
  canvas.remove();

};
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;It begins by checking to ensure that the passed element is of the correct type (it can only deal with &lt;code&gt;&amp;lt;text&amp;gt;&lt;/code&gt; elements). The &amp;ldquo;scaling factor&amp;rdquo; &lt;code&gt;k&lt;/code&gt; is hardcoded into the function. &lt;code&gt;k = 10&lt;/code&gt; means that the HTML canvas will be made to be ten times the size of the original SVG element. &lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;Recall that it is necessary to scale up the canvas to avoid imprecise bounding boxes resulting from grainy images.&lt;/span&gt; 
 We then retrieve the SVG element that contains the text element.&lt;/p&gt;

&lt;p&gt;The next step is ugly but necessary. We want to set the font styling of the canvas to be the same as the passed element. However, there may be cases where the desired font is not loaded. We check this with the &lt;code&gt;if&lt;/code&gt; conditional. Presently, the method deals with this task by setting the SVG text and canvas fonts to be standard font (&amp;lsquo;sans&amp;rsquo;). This is one way of avoiding incorrect bounding boxes.&lt;/p&gt;

&lt;p&gt;In the next few lines we create and draw on a hidden canvas. If we viewed the canvas we would see large, black character(s) (in the correct font) on a white background. The position of the characters is the same as on the original SVG.&lt;/p&gt;

&lt;p&gt;Once we&amp;rsquo;ve drawn the canvas we can begin to extract information from it. The line &lt;code&gt;var imgData = ...&lt;/code&gt; returns a 1-D array of RGBA values in the specified area of the canvas. Here, we limit ourselves to the area of the canvas that contains the &amp;ldquo;loose&amp;rdquo; bounding box. The main benefit of doing this is that we know that the text is in that area of the canvas so we can restrict our search for minimal and maximal coordinates to this area. The next line actually retrieves the tight bounding box by calling the function &lt;code&gt;tightBBox&lt;/code&gt; (discussed below) with the image data as an argument.&lt;/p&gt;

&lt;p&gt;The process finishes by scaling and shifting the bounding box coordinates to fit the SVG.&lt;/p&gt;

&lt;h3 id=&#34;finding-the-tight-bounding-box:1956d6c4eb3b8644416373fe86aead14&#34;&gt;Finding the Tight Bounding Box&lt;/h3&gt;

&lt;p&gt;Once we have the array of RGBA values in hand we can find the bounding boxes by searching for changes in hue. This task is carried out by two functions:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; arrayIndex1d3d &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; (ii, w, h, c) {
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Given ImageData.data index, get tuple location of pixel&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; out &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color: #666666&#34;&gt;-99&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;-99&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;-99&lt;/span&gt;];

  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// What column?&lt;/span&gt;
  out[&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.floor(ii &lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt; (c &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; w));
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// What row?&lt;/span&gt;
  out[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.floor((ii &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; (out[&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; c &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; w)) &lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt; c);
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// What Channel?&lt;/span&gt;
  out[&lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;] &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; ii &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; c;

  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; out;
}

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; tightBBox &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; (data) {
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Get a tight bounding box for the image data.&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; xyz;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; xmin &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; data.width &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;, xmax &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;-1&lt;/span&gt;, ymin &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; data.height &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;, ymax &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;-1&lt;/span&gt;;

  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; ii &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;3&lt;/span&gt;; ii &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; data.data.length; ii &lt;span style=&#34;color: #666666&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;4&lt;/span&gt;) {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (data.data[ii] &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;) {
      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Get coordinate in terms of (x, y, z)&lt;/span&gt;
      xyz &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; arrayIndex1d3d(ii, data.width, data.height, &lt;span style=&#34;color: #666666&#34;&gt;4&lt;/span&gt;);
      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Update bounds&lt;/span&gt;
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (xyz[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; xmin) { xmin &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; xyz[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]; }
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (xyz[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; xmax) { xmax &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; xyz[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]; }
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (xyz[&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; ymin) { ymin &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; xyz[&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;]; }
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (xyz[&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; ymax) { ymax &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; xyz[&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;]; }
    }
  }

  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; {x&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; xmin, y&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; ymin, width&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; xmax &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; xmin, height&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; ymax &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; ymin,};
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The second function, &lt;code&gt;tightBBox&lt;/code&gt;, is called from &lt;code&gt;getTightBBox&lt;/code&gt;. In short, this function is going to loop through each &amp;ldquo;pixel&amp;rdquo; and determine if there is color in the pixel. If there is, then we know that we&amp;rsquo;re in a pixel that is part of the character(s). The next step is to see if this pixel is at a boundary of the character. We do this by comparing the &amp;ldquo;x&amp;rdquo; and &amp;ldquo;y&amp;rdquo; coordinates of the pixel to the current minimal and maximal elements and update them if needed.&lt;/p&gt;

&lt;h3 id=&#34;dealing-with-image-data:1956d6c4eb3b8644416373fe86aead14&#34;&gt;Dealing With Image Data&lt;/h3&gt;

&lt;p&gt;The pixel data that we have in &lt;code&gt;data.data&lt;/code&gt; is a 1D array. Each pixel is represented by four consecutive entries which specify the &amp;ldquo;R&amp;rdquo;, &amp;ldquo;G&amp;rdquo;, &amp;ldquo;B&amp;rdquo;, and &amp;ldquo;A&amp;rdquo; values, respectively. Here is a short example of the data structure for a monochrome image:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;  R    G    B    A  &lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt; R    G    B    A  &lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt; R  , G  , B  , A  &lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt; ...
[ &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;  , &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;  , &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;  , &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;  , &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;  , &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;  , &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;  , &lt;span style=&#34;color: #666666&#34;&gt;255&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;  , &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;  , &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;  , &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;  , ... ]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Notice that all pixels are technically &amp;ldquo;black&amp;rdquo; because the RGB entries are all 0. Only the &amp;ldquo;A&amp;rdquo; entry changes. An &amp;ldquo;A&amp;rdquo; value of &amp;ldquo;0&amp;rdquo; will show up as white; a value of &amp;ldquo;255&amp;rdquo; will show up as black. We save on computation time by only testing if these &amp;ldquo;A&amp;rdquo; characters are non-zero.&lt;/p&gt;

&lt;p&gt;Once we know that a pixel is non-zero we want to figure out the &amp;ldquo;x&amp;rdquo; and &amp;ldquo;y&amp;rdquo; coordinates of the pixel. This task is done by the function &lt;code&gt;arrayIndex1d3d&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;usage-fonts:1956d6c4eb3b8644416373fe86aead14&#34;&gt;Usage: Fonts&lt;/h2&gt;

&lt;p&gt;How do we make sure that any non-standard fonts are loaded before making the tight bounding box? The one method that will definitely work involves using the WebFont.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s one example, which is taken from the application at the top of the page:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; fonts &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;Roboto&amp;quot;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;Permanent Marker&amp;quot;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;Condiment&amp;quot;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;Reenie Beanie&amp;quot;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;Monoton&amp;quot;&lt;/span&gt;];

WebFontConfig &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; {
  google&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; {
    families&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; fonts,
  },
  active&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; start,
};

(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; (d) {
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; wf &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; d.createElement(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;script&amp;#39;&lt;/span&gt;),
    s &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; d.scripts[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;];
  wf.src &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js&amp;#39;&lt;/span&gt;;
  wf.async &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;true&lt;/span&gt;;
  s.parentNode.insertBefore(wf, s);
})(&lt;span style=&#34;color: #008000&#34;&gt;document&lt;/span&gt;);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// All other code....&lt;/span&gt;

  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; start() {
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Once the code is loaded enable button&lt;/span&gt;
    drawChar(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;1&amp;#39;&lt;/span&gt;, fc.node().value, fs.node().value, g, h, w);
    submit.attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;disabled&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;null&lt;/span&gt;);
  }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;At the top we specified what fonts ought to be loaded. As part of this process we specified a function (&lt;code&gt;start&lt;/code&gt;) that will be called once all of the fonts are active. In this case I disabled the &amp;ldquo;Make Example&amp;rdquo; button until the fonts were loaded.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:1956d6c4eb3b8644416373fe86aead14&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Okay, that&amp;rsquo;s all I have. Why did I make this? Depending on how things develop, I may use this to make synthetic data for my table reading application. Time will tell&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Drawing With D3.js Part 4: Data Extraction</title>
      <link>https://michaelwooley.github.io/posts/drawing-4/</link>
      <pubDate>Fri, 15 Sep 2017 20:39:59 -0400</pubDate>
      
      <guid>https://michaelwooley.github.io/posts/drawing-4/</guid>
      <description>

&lt;p&gt;In the fourth installment of this series I&amp;rsquo;m going to focus on extracting data from our drawing. What are we trying to do? Suppose that we have a picture of a table on our canvas. We&amp;rsquo;ll draw a bunch of bounding boxes/rectangles around different elements of the canvas (e.g. a &amp;ldquo;row&amp;rdquo;-type bounding box around a row). When we&amp;rsquo;re done annotating the table we&amp;rsquo;ll hit &amp;ldquo;submit&amp;rdquo; and the program will extract information about the bounding boxes and put them in a data structure that we can use later. This is much easier to understand with an example.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s what we&amp;rsquo;re going to create:&lt;/p&gt;

&lt;figure&gt;
&lt;label for=&#34;main-sample&#34; class=&#34;margin-toggle&#34;&gt;&amp;#8853;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;main-sample&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;marginnote&#34;&gt;See the full set of controls and code at the &lt;a href=&#34;https://gist.github.com/michaelwooley/98fc0def4c581fe86f53a4d86fe75504&#34;&gt;gist&lt;/a&gt;. Believe it or not, that actually was the first good example table that I came across! &lt;br&gt;&lt;em&gt;Image Source:&lt;/em&gt; Jones, Hugh R. &amp;ldquo;The Perils and Protection of Infant Life.&amp;rdquo; &lt;em&gt;Journal of the Royal Statistical Society&lt;/em&gt; 57, no. 1 (1894): 1-103. (via &lt;a href=&#34;https://babel.hathitrust.org/cgi/pt?id=njp.32101068976792;seq=133&#34;&gt;HathiTrust&lt;/a&gt;)&lt;/span&gt;
&lt;div class=&#34;sample-div&#34;&gt;&lt;/div&gt;
&lt;/figure&gt;


&lt;p&gt;As you can see, we&amp;rsquo;ve made a good deal of progress towards creating an image annotation program. With the data that we&amp;rsquo;re extracting we could begin to train a neural network to extract the data from these old tables.&lt;label for=&#34;overdue-explain&#34; class=&#34;margin-toggle&#34;&gt;&amp;#8853;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;overdue-explain&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;marginnote&#34;&gt;I&amp;rsquo;m overdue for a post that gives a big picture idea about what this project is all about.&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;What do we need to add relative to our end-product from &lt;a href=&#34;https://michaelwooley.github.io/posts/drawing-3/&#34;&gt;Part 3&lt;/a&gt;?&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Add functionality to handle image input.&lt;/li&gt;
&lt;li&gt;Add a &amp;ldquo;data extraction&amp;rdquo; method for pulling bounding box data from the canvas.&lt;/li&gt;
&lt;li&gt;Introduce some additional formatting to add buttons and controls.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I will warn you that the code has become somewhat&amp;hellip; (what&amp;rsquo;s the word?) &lt;em&gt;convoluted&lt;/em&gt;. Before any additional posts extend this code I will probably spend some time rewriting it so that it is more modular. Besides making the code easier to understand, it will also make it easier to add and extend new features. Due to this, I will in this post mostly focus on elements of the new methods and spend less time on how they (currently) fit into the current code structure.&lt;/p&gt;

&lt;h2 id=&#34;the-base-image:4e048ec189f37fde3524c915d7fe71a9&#34;&gt;The Base Image&lt;/h2&gt;

&lt;p&gt;Ultimately, we want to extract data about the bounding boxes of elements in a &amp;ldquo;base&amp;rdquo; image.&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;For example, the base image in the above example is the table.&lt;/span&gt; 
 To do this correctly we&amp;rsquo;ll need to take some care in handling this base image. In particular, we&amp;rsquo;ll need to make sure that the coordinates from the SVG that we draw on are correctly transformed to the coordinates of the underlying image. The main &amp;ldquo;trick&amp;rdquo; will be to store the original size information about the image as data that can be called on later.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the current code for loading an image given an argument &lt;code&gt;arg&lt;/code&gt;, which is equal to the image&amp;rsquo;s url:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;SVGCanvas.prototype.loadImage &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; (arg) {
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Load an image to the canvas.&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; self &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;;

  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//// Add zoom and pan group&lt;/span&gt;
  self.zoomG &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; self.svg
    .append(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;g&amp;#39;&lt;/span&gt;)
    .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;class&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;zoom-group&amp;#39;&lt;/span&gt;)
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//// Adding&lt;/span&gt;
  self.img &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; self.zoomG.append(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;image&amp;#39;&lt;/span&gt;)
    .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;href&amp;#39;&lt;/span&gt;, arg)
    .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;width&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;98%&amp;#39;&lt;/span&gt;)
    .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;height&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;98%&amp;#39;&lt;/span&gt;)
    .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;x&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;1%&amp;#39;&lt;/span&gt;)
    .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;y&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;1%&amp;#39;&lt;/span&gt;)
    .call(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; () {
      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Call this function to get size attributes for the &lt;/span&gt;
      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// displayed and actual image.&lt;/span&gt;
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; image &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;new&lt;/span&gt; Image();      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Create a new image &lt;/span&gt;
      image.onload &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; () {  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// What should happen when the image is loaded&lt;/span&gt;
        imgBB &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; self.img.node().getBBox();
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; d &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; {};
        d.height &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; image.naturalHeight;
        d.width &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; image.naturalWidth;
        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Get x/y coordinates and scaling:&lt;/span&gt;
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (d.height &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; d.width) {
          d.scale &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; (imgBB.height &lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt; d.height);
          d.x &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; (self.options.w &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; d.scale &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; d.width) &lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;;
          d.y &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; imgBB.y;
        } &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;else&lt;/span&gt; {
          d.scale &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; (imgBB.width &lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt; d.width);
          d.x &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; imgBB.x;
          d.y &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; (self.options.h &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; d.scale &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; d.height) &lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;;
        }
        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Reformat image attributes&lt;/span&gt;
        self.img
          .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;width&amp;#39;&lt;/span&gt;, d.scale &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; d.width)
          .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;height&amp;#39;&lt;/span&gt;, d.scale &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; d.height)
          .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;x&amp;#39;&lt;/span&gt;, d.x)
          .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;y&amp;#39;&lt;/span&gt;, d.y);
        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Assign as data&lt;/span&gt;
        self.img.data &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; [d];
      }
      image.src &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; arg;        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Load the image by specifying an image source&lt;/span&gt;
    });
};
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The basic idea is to load the image as an &lt;code&gt;&amp;lt;image&amp;gt;&lt;/code&gt; within the &lt;code&gt;&amp;lt;svg&amp;gt;&lt;/code&gt;. Since the image is contained within the zoom group, it will expand and pan with the rest of the canvas.&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;In this version of the code the zoom group (i.e. &lt;code&gt;self.zoomG&lt;/code&gt;) is created within this method. This is a first pass at making it possible to add and toggle between multiple images at once.&lt;/span&gt; 
&lt;/p&gt;

&lt;p&gt;It is easy to specify that the image be resized to fit the canvas area (via, e.g., &lt;code&gt;.attr(&#39;width&#39;, &#39;98%&#39;)&lt;/code&gt;). While this approach creates an image that looks good, it gives us no indication of the actual size of the original image.  We can do this via a &lt;code&gt;.call()&lt;/code&gt;. If we just create an &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; element (i.e. not inside the &lt;code&gt;&amp;lt;svg&amp;gt;&lt;/code&gt;) then this image will have properties related to its &lt;code&gt;naturalHeight&lt;/code&gt; and &lt;code&gt;naturalWidth&lt;/code&gt;. Once we know these elements, we back out the &lt;code&gt;scale&lt;/code&gt;&amp;ndash;the size of the original image relative to the image on screen&amp;ndash;as well as the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; coordinates of the image on the screen relative to the SVG element. In doing so we need to check whether the image is vertically- (i.e. height &amp;gt; width) or horizontally-oriented via &lt;code&gt;if (d.height &amp;gt; d.width)&lt;/code&gt;. This is important because &lt;code&gt;imgBB.height&lt;/code&gt; and &lt;code&gt;imgBB.width&lt;/code&gt; will &lt;em&gt;appear&lt;/em&gt; to be equal. This seemingly-odd behavior comes from the fact that we set both  &lt;code&gt;height&lt;/code&gt; and &lt;code&gt;width&lt;/code&gt; attributes initially to 98%.&lt;/p&gt;

&lt;p&gt;We finish the &lt;code&gt;image.onload&lt;/code&gt; function by setting the image attributes to numbers from percentages (a safety measure) and by assigning the &lt;code&gt;d&lt;/code&gt; object to be part of the image&amp;rsquo;s data.&lt;/p&gt;

&lt;h2 id=&#34;data-extraction-and-handling:4e048ec189f37fde3524c915d7fe71a9&#34;&gt;Data Extraction and Handling&lt;/h2&gt;

&lt;p&gt;This section is going to come in two parts. First, we&amp;rsquo;re going to talk about extracting the data and organizing it. Then, we&amp;rsquo;ll talk about the methods used to preview the data selections. We&amp;rsquo;ll call each of these new methods when the user hits the &amp;ldquo;Submit&amp;rdquo; button.&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;The new buttons are discussed in the next section.&lt;/span&gt; 
&lt;/p&gt;

&lt;h3 id=&#34;data-extraction-and-structure:4e048ec189f37fde3524c915d7fe71a9&#34;&gt;Data Extraction and Structure&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;re going to start out by creating a JSON-like data object that contains information about the image and the bounding boxes. The code is fairly straightforward:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;SVGCanvas.prototype.dataCompile &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; () {
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// A function for compiling all of the data on the canvas into a&lt;/span&gt;
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//  json data structure.&lt;/span&gt;
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// &lt;/span&gt;
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// FUTURE: &lt;/span&gt;
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//  More metadata&lt;/span&gt;
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//  Accomodate more than one image.&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; self &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; out &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; [];

  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// One file for each image (will have more in future).&lt;/span&gt;
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//// Initialize object&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; out_i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; {
    meta&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; {},
    bb&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; {}
  };
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//// Get image bounding box.&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; imgBB &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; self.img.node().getBBox();
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Get Metadata - Add more later.&lt;/span&gt;
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//// File name w/ path&lt;/span&gt;
  out_i.meta.href &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; self.img.attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;href&amp;#39;&lt;/span&gt;);
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//// File size&lt;/span&gt;
  out_i.meta.height &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; self.img.data[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;].height;
  out_i.meta.width &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; self.img.data[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;].width;
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//// Common Name/Identifier&lt;/span&gt;
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Get bounding boxes&lt;/span&gt;
  self.zoomG.selectAll(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;g.g-rect&amp;#39;&lt;/span&gt;)
    .each(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; (d, i) {
      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Retrieve rectangle bounding boxes _relative to image_.&lt;/span&gt;
      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Follows convention from VOC2008: &lt;/span&gt;
      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// http://host.robots.ox.ac.uk/pascal/VOC/voc2008/HTMLdoc/voc.HTML#SECTION00092000000000000000&lt;/span&gt;
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; d2 &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; {};
      d2.xmin &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.max(d.x &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; imgBB.x, &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt; self.img.data[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;].scale;
      d2.ymin &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.max(d.y &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; imgBB.y, &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt; self.img.data[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;].scale;
      d2.xmax &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.min(d.x &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; imgBB.x &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; d.w, imgBB.width) &lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt; self.img.data[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;].scale;
      d2.ymax &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.min(d.y &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; imgBB.y &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; d.h, imgBB.height) &lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt; self.img.data[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;].scale;
      d2.type &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; d.type;
      out_i.bb[d.id] &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; d2;
    });
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Push onto full dataset.&lt;/span&gt;
  out.push(out_i);

  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; out;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We&amp;rsquo;re going to have an array (&lt;code&gt;out&lt;/code&gt;) that contains an object for each image (there is only one at the moment). The basic structure of the data is:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;out_i&lt;/code&gt;: A data object for an image.

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.meta&lt;/code&gt;: Metadata about the image:&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.href&lt;/code&gt;: Image Source&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.height&lt;/code&gt;: Image natural height.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.width&lt;/code&gt;: Image natural width.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.bb&lt;/code&gt;: Bounding box data objects:&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.xmin&lt;/code&gt;, &lt;code&gt;.ymin&lt;/code&gt;, &lt;code&gt;.xmax&lt;/code&gt;, &lt;code&gt;.ymax&lt;/code&gt;: Bounding coordinates.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.type&lt;/code&gt;: Type of bounding box.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code&gt;type&lt;/code&gt; of the bounding box will be something like &amp;ldquo;table&amp;rdquo;, &amp;ldquo;row&amp;rdquo;, &amp;ldquo;column&amp;rdquo;, &amp;ldquo;number&amp;rdquo;, etc. It is controlled by &lt;code&gt;SVGCanvas.state&lt;/code&gt;, of which more on below.&lt;/p&gt;

&lt;p&gt;Notice how we needed to use the natural image dimensions, location, and the scaling parameters (stored in the &lt;code&gt;img&lt;/code&gt; data) in order to ensure that our bounding boxed correspond to the original image and not just what we saw on the screen. The &lt;code&gt;Math.max&lt;/code&gt; and &lt;code&gt;Math.min&lt;/code&gt; calls account for cases where the rectangle was drawn within the canvas but off the base image.&lt;/p&gt;

&lt;h3 id=&#34;check-displaying-the-data:4e048ec189f37fde3524c915d7fe71a9&#34;&gt;Check: Displaying The Data&lt;/h3&gt;

&lt;p&gt;We can check whether the bounding box data is correct by creating a function that displays the bounding boxes. The &lt;code&gt;SVGCanvas.previewSelections&lt;/code&gt; method does just that. Here is a snippet of the code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;SVGCanvas.prototype.previewSelections &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; (d) {
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Make a table to preview the selections made above.&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; self &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;;

  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// More....&lt;/span&gt;
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// - Load into a new window&lt;/span&gt;
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// - Create Table and headers&lt;/span&gt;

  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Cycle through output.&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; ii &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;; ii &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; d.length; ii&lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;) {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; bb &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;in&lt;/span&gt; d[ii].bb) {

      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Get the data&lt;/span&gt;
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; d_i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; d[ii].bb[bb];
      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Set the height and width&lt;/span&gt;
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; w &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; (d_i.xmax &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; d_i.xmin) &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; self.img.data[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;].scale;
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; h &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; (d_i.ymax &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; d_i.ymin) &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; self.img.data[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;].scale;
      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Make the row&lt;/span&gt;
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; row &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; tbody.append(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;tr&amp;#39;&lt;/span&gt;);
      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Append the image&lt;/span&gt;
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; canvas &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; row.append(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;td&amp;#39;&lt;/span&gt;)
        .append(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;canvas&amp;#39;&lt;/span&gt;)
        .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;width&amp;#39;&lt;/span&gt;, w)
        .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;height&amp;#39;&lt;/span&gt;, h);
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; ctx &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; canvas.node().getContext(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;2d&amp;quot;&lt;/span&gt;);
      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ~~!!! ONLY WORKING ON CHROME !!!~~&lt;/span&gt;
      ctx.drawImage(self.img.node(), 
                    d_i.xmin, d_i.ymin, 
                    d_i.xmax &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; d_i.xmin, d_i.ymax &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; d_i.ymin, 
                    &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;, w, h);
      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Append other info&lt;/span&gt;
      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
    }
  }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The initial steps (which aren&amp;rsquo;t shown) create a new page and start an HTML table. I decided to create a new page to make it easy to compare the displayed bounding boxes with the selections on the canvas.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;for&lt;/code&gt; loop then cycles through each of the bounding boxes in the data that was just generated in &lt;code&gt;SVGCanvas.dataCompile&lt;/code&gt;. The main thing to observe is the creation of the preview boxes. To create the cropped selection we draw a new HTML &lt;code&gt;canvas&lt;/code&gt; object in one of the table cells. We begin by appending a &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; element that is the same height and width as the cell and getting its context. The important line is &lt;code&gt;ctx.drawImage&lt;/code&gt;. The arguments for that method are:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Where:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;image&lt;/code&gt; is the image to draw.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sx&lt;/code&gt;/&lt;code&gt;sy&lt;/code&gt; are the upper-left/starting &lt;code&gt;x&lt;/code&gt;/&lt;code&gt;y&lt;/code&gt; coordinate of the cropped image.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sWidth&lt;/code&gt;/&lt;code&gt;sHeight&lt;/code&gt; are the width/height of the cropped image.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dx&lt;/code&gt;/&lt;code&gt;dy&lt;/code&gt; are the starting &lt;code&gt;x&lt;/code&gt;/&lt;code&gt;y&lt;/code&gt; coordinates in the destination canvas.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dWidth&lt;/code&gt;/&lt;code&gt;dHeight&lt;/code&gt; are the width/height of the image in the destination canvas.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Basically, this call is going out to the original image and drawing the pixels specified in the &lt;code&gt;sx&lt;/code&gt;, &lt;code&gt;sy&lt;/code&gt;, &lt;code&gt;sWidth&lt;/code&gt;, and &lt;code&gt;sHeight&lt;/code&gt; parameters. That is, these parameters refer to coordinates in the original base image, not the SVG that we created previously. Therefore, this constitutes a valid test for whether our bounding box coordinates are correct with respect to the original image.&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;note-browser-compatibility:4e048ec189f37fde3524c915d7fe71a9&#34;&gt;Note: Browser Compatibility&lt;/h4&gt;

&lt;p&gt;All of the above works well in Chrome. When I tested the code in Firefox I found that there was a problem related to the &lt;code&gt;ctx.drawImage()&lt;/code&gt; call. In short, it appears that Firefox cannot take an SVG &lt;code&gt;&amp;lt;image&amp;gt;&lt;/code&gt; element as the &lt;code&gt;image&lt;/code&gt; argument whereas Chrome can. Otherwise the code should work well on other browsers.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;buttons-and-visual-organization:4e048ec189f37fde3524c915d7fe71a9&#34;&gt;Buttons and Visual Organization&lt;/h2&gt;

&lt;p&gt;For the first time we need to actually add buttons to control what is happening on the canvas. In order to do this I created a simple button utility for toggling between multiple choices. The mainly did this to get more experience in creating elements and to avoid having to reload Bootstrap JavaScript every time the page is loaded.&lt;/p&gt;

&lt;h3 id=&#34;button-toggling:4e048ec189f37fde3524c915d7fe71a9&#34;&gt;Button Toggling&lt;/h3&gt;

&lt;p&gt;The button toggling utility is a standalone file.&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;The full code can be found at this &lt;a href=&#34;https://gist.github.com/michaelwooley/b486bc069e417395dbc421c21b49ffbe&#34;&gt;gist&lt;/a&gt;.&lt;/span&gt; 
 Its dependencies are &lt;a href=&#34;https://v4-alpha.getbootstrap.com/&#34;&gt;Bootstrap CSS&lt;/a&gt; and &lt;a href=&#34;https://github.com/d3/d3&#34;&gt;D3.js&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The usage is designed to be simple. The user inputs an object containing:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Information about each choice in the form of an Array.&lt;/li&gt;
&lt;li&gt;A CSS selector for the DOM element that the button should be appended to&lt;/li&gt;
&lt;li&gt;A callback function to be called each time the button is pressed. The callback function takes one argument, which is the name of the button that was selected. (E.g. if &amp;ldquo;Table&amp;rdquo; is pressed, then the argument &amp;ldquo;Table&amp;rdquo; is passed to the function).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here, I used this code to create the dropdown list. The options consist in each type of annotation that we can add to the canvas. The callback function switches the canvas &lt;code&gt;state&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the basic idea:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Initialize the set of possible states&lt;/span&gt;
self.stateData &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; [{
      name&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;Table&amp;#39;&lt;/span&gt;,
      color&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;#d32f2f&amp;#39;&lt;/span&gt;,
      count&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;,
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;rect&amp;#39;&lt;/span&gt;,
      id&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;Table-0&amp;#39;&lt;/span&gt;,
    },
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// more....&lt;/span&gt;
    {
      name&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;Word&amp;#39;&lt;/span&gt;,
      color&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;#0288d1&amp;#39;&lt;/span&gt;,
      count&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;,
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;rect&amp;#39;&lt;/span&gt;,
      id&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;Word-0&amp;#39;&lt;/span&gt;,
    }];
self.state &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; self.stateData[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;];

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; callbackStateToggle(arg) {
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// What to do when the state toggle buttons are pushed:&lt;/span&gt;
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 1. Save the old state to self.stateData&lt;/span&gt;
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 2. Make self.state the clicked state.&lt;/span&gt;
}
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//// Set the Options&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; stateToggleOpt &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; {
  type&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;dropdown&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Alt. is a button bank&lt;/span&gt;
  addTo&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Where to add to the dropdown,&lt;/span&gt;
  clickCall&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; callbackStateToggle,
};
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//// Create the new object&lt;/span&gt;
self.stateTogglers &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;new&lt;/span&gt; ButtonToggle(self.stateData, stateToggleOpt);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;By switching the canvas state, we switch the color of the rectangles that are drawn and, more substantially, we add classes to the rectangle groups that allow us to identify the annotation type when we go to compile the data.&lt;/p&gt;

&lt;h3 id=&#34;the-submit-button:4e048ec189f37fde3524c915d7fe71a9&#34;&gt;The &amp;ldquo;Submit&amp;rdquo; Button&lt;/h3&gt;

&lt;p&gt;The &amp;ldquo;Submit&amp;rdquo; button is simply an HTML &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; with Bootstrap styling. We then attach an event listener to it that calls the data compile and preview methods discussed above.&lt;/p&gt;

&lt;p&gt;The code is just:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; addDataSubmitButton(addTo) {
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Make a button that will submit the necessary data to the system.&lt;/span&gt;

  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Add the button&lt;/span&gt;
  d3.select(addTo)
    .append(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;button&amp;#39;&lt;/span&gt;)
    .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;class&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;btn btn-dark submit-button&amp;#39;&lt;/span&gt;)
    .style(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;font&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;caption&amp;#39;&lt;/span&gt;)
    .text(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;Submit&amp;#39;&lt;/span&gt;)
    .on(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;click&amp;#39;&lt;/span&gt;, onclickCallback);

  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Define the &amp;#39;onclick&amp;#39; callback&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; onclickCallback() {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; out &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; self.dataCompile(); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// &amp;lt;= Data Compile Code Discussed Above&lt;/span&gt;
    console.log(out);             &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// &amp;lt;= See raw data in console.&lt;/span&gt;
    self.previewSelections(out);  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// &amp;lt;= Preview in browser&lt;/span&gt;
  }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;addTo&lt;/code&gt; parameter is a CSS selector stating where we want to add the button.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:4e048ec189f37fde3524c915d7fe71a9&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;In this post I&amp;rsquo;ve demonstrated that we have a viable image annotation tool. In particular, we demonstrated that we can extract bounding boxes from each image and get them into a data structure that can be used to train a model.&lt;/p&gt;

&lt;p&gt;The main gaps in the current code have to do with image handling. We need to add the ability to &lt;em&gt;choose&lt;/em&gt; the input image and handle multiple images at once. This is where further modularization of the code will come in handy. The basic idea will be to create &lt;code&gt;&amp;lt;g&amp;gt;&lt;/code&gt; elements for each image that will contain both the image and the annotation rectangles. We can then add controls for switching between each image. Ultimately, we&amp;rsquo;ll want to be able to download this data.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Drawing With D3.js Part 3: Moving and Resizing</title>
      <link>https://michaelwooley.github.io/posts/drawing-3/</link>
      <pubDate>Tue, 12 Sep 2017 20:39:59 -0400</pubDate>
      
      <guid>https://michaelwooley.github.io/posts/drawing-3/</guid>
      <description>

&lt;p&gt;We&amp;rsquo;re going build on the foundation we&amp;rsquo;ve created in posts &lt;a href=&#34;https://michaelwooley.github.io/posts/drawing-1&#34;&gt;1&lt;/a&gt; and &lt;a href=&#34;https://michaelwooley.github.io/posts/drawing-2&#34;&gt;2&lt;/a&gt; of this series by adding the ability to move, resize, and delete rectangles that we&amp;rsquo;ve already added to the canvas. The basic idea will be to add additional, invisible rectangles at the corners and edges of the rectangles. We&amp;rsquo;ll then attach behaviors to these bounding rectangles in order to resize, reshape, and delete.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s what we&amp;rsquo;re going to create:&lt;/p&gt;

&lt;figure&gt;
&lt;label for=&#34;main-sample&#34; class=&#34;margin-toggle&#34;&gt;&amp;#8853;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;main-sample&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;marginnote&#34;&gt;Try hovering over the edges of rectangles and &lt;code&gt;ctrl + click&lt;/code&gt; gestures. See the full set of controls and code at the &lt;a href=&#34;https://gist.github.com/michaelwooley/b5edc61e9b9a243ca9e8b55dc46411aa&#34;&gt;gist&lt;/a&gt;.&lt;/span&gt;
&lt;div class=&#34;sample-div&#34;&gt;&lt;/div&gt;
&lt;/figure&gt;


&lt;p&gt;I&amp;rsquo;m going to tackle this in the following set of steps:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Change the basic structure of the code by:

&lt;ul&gt;
&lt;li&gt;Adding the notion of a &lt;strong&gt;state&lt;/strong&gt;, which will contain information about what sort of rectangles we&amp;rsquo;re adding.&lt;/li&gt;
&lt;li&gt;Adding a notion of &lt;strong&gt;active&lt;/strong&gt; rectangles.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Append a full complement of rectangles to the corners and edges of each added rectangle. We will use these elements to detect events.&lt;/li&gt;
&lt;li&gt;Add the ability to &lt;strong&gt;delete&lt;/strong&gt; &lt;em&gt;several&lt;/em&gt; rectangles at once. This will draw on our notion of &lt;em&gt;active&lt;/em&gt; rectangles, which I will discuss later.&lt;/li&gt;
&lt;li&gt;Attach &lt;strong&gt;resize&lt;/strong&gt; and &lt;strong&gt;move&lt;/strong&gt; behaviors to our elements.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Okay, that&amp;rsquo;s a lot to do in one post. I&amp;rsquo;m going to be a bit more sketchy than in previous posts and focus attention on what I consider to be the most important parts.&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;Of course, if you&amp;rsquo;re reading this and really want to figure out what&amp;rsquo;s going on but can&amp;rsquo;t please feel free to get in touch!&lt;/span&gt; 
&lt;/p&gt;

&lt;h2 id=&#34;modifying-the-old-to-accommodate-the-new:648b6abe57ff61375f3b845700219895&#34;&gt;Modifying the Old to Accommodate the New&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;m going to start out by discussing what parts of our old code we need to change so that we can work in the new code.&lt;/p&gt;

&lt;h3 id=&#34;defining-a-canvas-state:648b6abe57ff61375f3b845700219895&#34;&gt;Defining a Canvas &amp;ldquo;&lt;code&gt;state&lt;/code&gt;&amp;ldquo;&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;re going to add a notion of a &amp;ldquo;state&amp;rdquo; to the canvas element. This element will come in handy when we start to make the canvas elements more elaborate and extract data from them. For now, though, it will just come in handy when we need to do things like name elements.&lt;/p&gt;

&lt;p&gt;Within the &lt;code&gt;SVGCanvas&lt;/code&gt; constructor let&amp;rsquo;s create a state like so:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; SVGCanvas(options) {
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Previous ...&lt;/span&gt;

  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Set the state (elaborate on more later)&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.state &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; {
    type&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;Table&amp;#39;&lt;/span&gt;,
    color&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;#d32f2f&amp;#39;&lt;/span&gt;,
    count&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;,
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;rect-table&amp;#39;&lt;/span&gt;,
    id&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;Table-0&amp;#39;&lt;/span&gt;,
  }

  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// more ...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As you can see, this is just an object that contains some information that looks sort of arbitrary. Indeed, for now, you should just think of all of this &amp;lsquo;Table&amp;rsquo; talk as a arbitrary name that we&amp;rsquo;ll give our rectangle.&lt;/p&gt;

&lt;h3 id=&#34;alterations-to-addrect:648b6abe57ff61375f3b845700219895&#34;&gt;Alterations to &lt;code&gt;addRect&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;We need to add and modify the methods that we use to add rectangles (contained within the &lt;code&gt;SVGCanvas.addRect&lt;/code&gt; methods) to add resize, move, and delete functionality.&lt;/p&gt;

&lt;h4 id=&#34;using-the-state:648b6abe57ff61375f3b845700219895&#34;&gt;Using the &lt;code&gt;state&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;For today, we&amp;rsquo;ll use the &lt;code&gt;SVGCanvas.state&lt;/code&gt; property to define attributes of the added rectangles in the &lt;code&gt;SVGCanvas.addRect&lt;/code&gt; methods. In particular, in &lt;code&gt;SVGCanvas.addRect.start&lt;/code&gt; we&amp;rsquo;ll attach classes of &lt;code&gt;state.id&lt;/code&gt; to both the rectangle and the group that it is contained within. We&amp;rsquo;ll also update the &lt;code&gt;state.id&lt;/code&gt; and &lt;code&gt;state.count&lt;/code&gt; in &lt;code&gt;SVGCanvas.addRect.end&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 1 &lt;/span&gt;SVGCanvas.prototype.makeAddRect &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; () {
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 2 &lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Previous...&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 3 &lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 4 &lt;/span&gt;  start &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; () {
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 5 &lt;/span&gt;    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//Add a rectangle&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 6 &lt;/span&gt;    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 1. Get mouse location in SVG&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 7 &lt;/span&gt;    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; m &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; self.mouseOffset();
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 8 &lt;/span&gt;    x0 &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; m[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;];
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 9 &lt;/span&gt;    y0 &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; m[&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;];
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;10 &lt;/span&gt;    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 2. Add a new group&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;11 &lt;/span&gt;    self.Rect.g &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; self.zoomG
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;12 &lt;/span&gt;      .append(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;g&amp;#39;&lt;/span&gt;)
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;13 &lt;/span&gt;      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;class&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;g-rect &amp;#39;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; self.state.id);
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;14 &lt;/span&gt;    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 3. Make a rectangle&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;15 &lt;/span&gt;    self.Rect.r &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; self.Rect.g
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;16 &lt;/span&gt;      .append(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;rect&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// An SVG `rect` element&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;17 &lt;/span&gt;      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;x&amp;#39;&lt;/span&gt;, x0) &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Position at mouse location&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;18 &lt;/span&gt;      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;y&amp;#39;&lt;/span&gt;, y0)
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;19 &lt;/span&gt;      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;width&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Make it tiny&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;20 &lt;/span&gt;      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;height&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;)
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;21 &lt;/span&gt;      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;class&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;rect-main &amp;#39;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; self.state.&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; self.state.id)
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;22 &lt;/span&gt;      .style(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;stroke&amp;#39;&lt;/span&gt;, self.state.color)
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;23 &lt;/span&gt;      .style(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;fill&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;none&amp;#39;&lt;/span&gt;);
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;24 &lt;/span&gt;    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 4. Make it active.&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;25 &lt;/span&gt;    self.setActive(self.state.id);
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;26 &lt;/span&gt;  }
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;27 &lt;/span&gt;  drag &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; () {...}
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;28 &lt;/span&gt;  end &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; () {
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;29 &lt;/span&gt;    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// What to do on mouseup&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;30 &lt;/span&gt;    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Add Rectangle Transformation Methods&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;31 &lt;/span&gt;    self.transformRect();
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;32 &lt;/span&gt;    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Clear out rect.&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;33 &lt;/span&gt;    self.Shapes[self.state.id] &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; self.Rect;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;34 &lt;/span&gt;    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Update count and id&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;35 &lt;/span&gt;    self.state.count &lt;span style=&#34;color: #666666&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;36 &lt;/span&gt;    self.state.id &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; self.state.type &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;-&amp;#39;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; self.state.count;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;37 &lt;/span&gt;  }
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;38 &lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;39 &lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// more...&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;40 &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;


&lt;h4 id=&#34;active-groups:648b6abe57ff61375f3b845700219895&#34;&gt;Active Groups&lt;/h4&gt;

&lt;p&gt;In line 25 we called a new method, &lt;code&gt;self.setActive&lt;/code&gt;, using the new rectangle&amp;rsquo;s &lt;code&gt;id&lt;/code&gt; as the argument. We&amp;rsquo;ll discuss the idea of active groups in more detail below. One immediate effect of being an active group is that the rectangle&amp;rsquo;s color is brighter.&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;In particular, we&amp;rsquo;re shifting the rectangle&amp;rsquo;s &lt;code&gt;stroke-opacity&lt;/code&gt; attribute from 0.5 to 1. The CSS styling for this part is a bit more detailed than previously (but still relatively simple).&lt;/span&gt; 
&lt;/p&gt;

&lt;h4 id=&#34;adding-rectangle-transformation-methods:648b6abe57ff61375f3b845700219895&#34;&gt;Adding Rectangle Transformation Methods&lt;/h4&gt;

&lt;p&gt;In line 31 we called a new method, &lt;code&gt;self.transformRect&lt;/code&gt;. This is the method that we&amp;rsquo;re going to use to attach all of the resize and move behaviors below.&lt;/p&gt;

&lt;h2 id=&#34;rectangle-groups:648b6abe57ff61375f3b845700219895&#34;&gt;Rectangle Groups&lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;re going to want our rectangles to react to gestures at the edges and corners. However, we can only &lt;em&gt;explicitly&lt;/em&gt; attach behaviors to an entire &lt;code&gt;&amp;lt;rect&amp;gt;&lt;/code&gt; element, not to edges and corners. To get around this we&amp;rsquo;re going to add several invisible rectangles at the corners and edges of each rectangle that is drawn. We&amp;rsquo;ll then attach behaviors to these elements. The downside of this strategy is that we now have to keep track of many more elements than previously. To deal with this, we&amp;rsquo;ll organize these elements into groups.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s some sample html of what the rectangle group will look like:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;&amp;lt;!--  The Group --&amp;gt;&lt;/span&gt;
&amp;lt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;g&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;g-rect Table-0 active&amp;quot;&lt;/span&gt;&amp;gt;
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;&amp;lt;!--  The visible rectangle --&amp;gt;&lt;/span&gt;
  &amp;lt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;rect&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;59&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;139&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;width&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;90&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;height&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;67&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;rect-main rect-table Table-0&amp;quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;rect&lt;/span&gt;&amp;gt;
  
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;&amp;lt;!-- Hidden Rectangles on each edge of visible rectangle --&amp;gt;&lt;/span&gt;
  &amp;lt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;rect&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;rectEdge cornerEdge Table-0 rectEdge-bottom&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;63&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;201&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;width&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;81&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;height&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;9&amp;quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;rect&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;rect&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;rectEdge cornerEdge Table-0 rectEdge-top&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;63.0&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;134.0&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;width&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;81.0&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;height&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;9&amp;quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;rect&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;rect&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;rectEdge cornerEdge Table-0 rectEdge-right&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;145.0&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;143.0&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;width&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;9&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;height&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;58&amp;quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;rect&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;rect&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;rectEdge cornerEdge Table-0 rectEdge-left&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;54.0&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;143.0&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;width&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;9&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;height&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;58&amp;quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;rect&lt;/span&gt;&amp;gt;
  
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;&amp;lt;!-- Hidden Rectangles at each corner of visible rectangle --&amp;gt;&lt;/span&gt;
  &amp;lt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;rect&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;height&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;9&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;width&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;9&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;rectCorner cornerEdge nwse Table-0 rectCorner-botright&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;145.0&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;201.0&amp;quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;rect&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;rect&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;height&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;9&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;width&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;9&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;rectCorner cornerEdge nwse Table-0 rectCorner-topleft&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;54.0&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;134.0&amp;quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;rect&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;rect&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;height&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;9&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;width&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;9&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;rectCorner cornerEdge nesw Table-0 rectCorner-botleft&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;54.0&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;201.0&amp;quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;rect&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;rect&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;height&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;9&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;width&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;9&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;rectCorner cornerEdge nesw Table-0 rectCorner-topright&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;145.0&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;134.0&amp;quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;rect&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;g&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I have inserted a special &amp;ldquo;debug&amp;rdquo; flag into the code so that it is easy to see these &amp;ldquo;hidden&amp;rdquo; rectangles:&lt;/p&gt;

&lt;figure&gt;
&lt;label for=&#34;main-sample-2&#34; class=&#34;margin-toggle&#34;&gt;&amp;#8853;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;main-sample-2&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;marginnote&#34;&gt;This demo features the same code as the original demo but now the bounding rectangles are visible.&lt;/span&gt;
&lt;div class=&#34;sample-div-2&#34;&gt;&lt;/div&gt;
&lt;/figure&gt;


&lt;h3 id=&#34;adding-and-handling-the-rectangle-group:648b6abe57ff61375f3b845700219895&#34;&gt;Adding and Handling The Rectangle Group&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;re going to want all of these hidden rectangles to move along with the main rectangle. To do this we&amp;rsquo;re going to use a two-step approach. First, we&amp;rsquo;ll add some data to the group element containing information about the bounding box of the main (visible) rectangle. Then, we&amp;rsquo;ll define a function that sets the coordinates of each element in the group (i.e. visible, edge, and corner rectangles) as a function of this data. Any time we want to modify the rectangle, then, we&amp;rsquo;ll update the data and call the coordinate-setting function.&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;You might be wondering why I didn&amp;rsquo;t just use the group &lt;code&gt;transform&lt;/code&gt; attribute that I discussed in detail in part 2. The reason is that&amp;ndash;ultimately&amp;ndash;I&amp;rsquo;m going to want all of the rectangle groups to be on the same coordinate system so that I can extract data from them and compare rectangles. Thus, it makes sense to change the actual and not just apparent position of the rectangles.&lt;/span&gt; 
&lt;/p&gt;

&lt;p&gt;Here is a taste of the &lt;code&gt;SVGCanvas.transformRect&lt;/code&gt; method, which we call each time a new rectangle is added. You can see that we get the current rectangle and group; we then add the data (&lt;code&gt;p = {...}&lt;/code&gt;) to the group element. The &lt;code&gt;main&lt;/code&gt; sub-method finishes by calling another sub-method (&lt;code&gt;makeRectEdgeCorner&lt;/code&gt;), which adds the hidden bounding rectangles.&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;SVGCanvas.prototype.transformRect &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; () {
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; self &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; groupClass, debug, g, r, p, dbWidth;

  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; main &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; () {

    r &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; self.Rect.r;
    g &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; self.Rect.g;
    dbWidth &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; self.options.rectOpt.dbWidth;
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Set common class&lt;/span&gt;
    groupClass &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; self.state.id;
    debug &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; self.options.debug &lt;span style=&#34;color: #666666&#34;&gt;?&lt;/span&gt; (&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39; debug&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; (&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;);

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Add data to the group element&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; rBB &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; r.node().getBBox();
    p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; {
      x&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; rBB.x,
      y&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; rBB.y,
      w&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; rBB.width,
      h&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; rBB.height,
      id&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; groupClass,
    };
    g &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; g.data([p]);

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Add the hidden bounding rectangles&lt;/span&gt;
    makeRectEdgeCorner();
  }

  main();

  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; setCoordsData(d) {
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Set the coordinates of a rectangle-group&lt;/span&gt;

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; children &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; d3.selectAll(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;g.active.&amp;#39;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; d.id);

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Main Rectangle&lt;/span&gt;
    children.select(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;rect.rect-main&amp;#39;&lt;/span&gt;)
      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;x&amp;#39;&lt;/span&gt;, d.x)
      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;y&amp;#39;&lt;/span&gt;, d.y)
      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;width&amp;#39;&lt;/span&gt;, d.w)
      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;height&amp;#39;&lt;/span&gt;, d.h);

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// rectEdge.left&lt;/span&gt;
    children.select(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;rect.rectEdge.rectEdge-left&amp;#39;&lt;/span&gt;)
      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;x&amp;#39;&lt;/span&gt;, d.x &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; (dbWidth &lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;))
      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;y&amp;#39;&lt;/span&gt;, d.y &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; (dbWidth &lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;))
      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;width&amp;#39;&lt;/span&gt;, dbWidth)
      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;height&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.abs(d.h &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; dbWidth));

    ...
  }

  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Add move and resize methods&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; moveRect() {...}
  }

  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; resizeRect() {
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Resize the rectangle by dragging the corners&lt;/span&gt;

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; getDragCorners() {...}

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; makeContainer &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; (id) {...}

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Make drag containers for each &lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; {
      makeContainer&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; makeContainer,
    }
  }

  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Append helper rectEdges and rectCorners to g&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; makeRectEdgeCorner() {...}
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&#34;setting-coordinates:648b6abe57ff61375f3b845700219895&#34;&gt;Setting Coordinates&lt;/h3&gt;

&lt;p&gt;Notice the snippet of the function &lt;code&gt;setCoordsData&lt;/code&gt; in the code block above. This is the method that will be called to update the coordinates (i.e. &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, &lt;code&gt;width&lt;/code&gt;) of rectangles given the group dataset &lt;code&gt;d&lt;/code&gt;. It is a long function because we&amp;rsquo;re altering attributes in nine different elements (one visible, four edges, and four corners). In the end, though, the only part that requires a bit of thought is figuring out what the coordinates of the bounding rectangles ought to be in relation to the main rectangle.&lt;/p&gt;

&lt;p&gt;The basic idea is to find the child elements of the group pertaining to each shape. With the main rectangle the coordinates can be updated straightforwardly. The bounding rectangle on the left edge has coordinates that are relatively-straightforward functions of the main rectangle&amp;rsquo;s coordinates.&lt;/p&gt;

&lt;h2 id=&#34;moving-and-resizing-rectangles:648b6abe57ff61375f3b845700219895&#34;&gt;Moving and Resizing Rectangles&lt;/h2&gt;

&lt;p&gt;We define methods for moving and resizing the rectangles within &lt;code&gt;SVGCanvas.transformRect&lt;/code&gt;. As alluded to above, the basic strategy in both cases will be to 1.) register a mouse movement, 2.) update the group data elements (&lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, &lt;code&gt;width&lt;/code&gt;), and 3.) calling the &lt;code&gt;setCoordsData&lt;/code&gt; to actually move the elements.&lt;/p&gt;

&lt;p&gt;A new element of this code is that we&amp;rsquo;re going to update the &amp;ldquo;&lt;code&gt;active&lt;/code&gt;&amp;rdquo; status of each rectangle group when a move or resize occurs (just like when we add a new rectangle). I decided to make the rectangle movements something that occurs to all active rectangles (i.e. they move together). Rectangle resizes, however, only occur for the rectangle that the mouse is currently hovering over. This difference partly has to do with how the code is written at the moment. However, I also think that this behavior is more natural.&lt;/p&gt;

&lt;p&gt;Both of these behaviors are appended to the relevant bounding rectangles within the &lt;code&gt;makeRectEdgeCorner&lt;/code&gt; sub-method.&lt;/p&gt;

&lt;h3 id=&#34;moving:648b6abe57ff61375f3b845700219895&#34;&gt;Moving&lt;/h3&gt;

&lt;p&gt;We can move the rectangle by attaching a dragging behavior to the edge bounding rectangles. As with the &lt;code&gt;addRect&lt;/code&gt; method from part 1, we make a &lt;code&gt;moveRect&lt;/code&gt; method by defining functions specifying what should occur in the beginning, middle, and end of the drag.&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; moveRect() {
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Move the rectangle by dragging edges&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; activeG;

  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; start() {
    self.setActive(groupClass);
    self.svg.style(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;cursor&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;move&amp;#39;&lt;/span&gt;);
    activeG &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; d3.selectAll(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;g.active&amp;#39;&lt;/span&gt;);
  }

  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; drag() {

    activeG.each(
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; (d, i) {
          &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Alter Parameters&lt;/span&gt;
          d.x &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.max(&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.min(self.options.w &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; d.w, d.x &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; d3.event.dx));
          d.y &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.max(&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.min(self.options.h &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; d.h, d.y &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; d3.event.dy));

          &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Set Coordinates&lt;/span&gt;
          setCoordsData(d);
        }
      )
  }

  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; end() {
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Undo formatting&lt;/span&gt;
    self.svg.style(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;cursor&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;default&amp;#39;&lt;/span&gt;);
  }

  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// What to do on drag&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; dragcontainer &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; d3.drag()
    .on(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;start&amp;#39;&lt;/span&gt;, start)
    .on(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;drag&amp;#39;&lt;/span&gt;, drag)
    .on(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;end&amp;#39;&lt;/span&gt;, end);

  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; {
    drag&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; dragcontainer,
  }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;start&lt;/code&gt; method simply adds the clicked rectangle group to the set of &amp;ldquo;active&amp;rdquo; groups. Concretely, this means that the &lt;code&gt;&amp;lt;g&amp;gt;&lt;/code&gt; element now has the class &amp;ldquo;&lt;code&gt;active&lt;/code&gt;&amp;rdquo;. We then collect all of the active group elements in a variable, &lt;code&gt;activeG&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Some new techniques are introduced in the &lt;code&gt;drag&lt;/code&gt; method. When a drag occurs we use the &lt;code&gt;.each(...)&lt;/code&gt; method to carry out a function on &lt;em&gt;each&lt;/em&gt; of the elements in &lt;code&gt;activeG&lt;/code&gt;. The &lt;code&gt;.each&lt;/code&gt; call gives us variables &lt;code&gt;d&lt;/code&gt; and &lt;code&gt;i&lt;/code&gt;, which pertain to the group data and element count (i.e. fifth out of six active elements).&lt;/p&gt;

&lt;p&gt;We update the data with new &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; coordinates for the rectangle. The coordinate updates are written so that the element cannot exceed the boundaries of the &lt;code&gt;&amp;lt;svg&amp;gt;&lt;/code&gt; element. Because the data object is mutable the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; coordinates of the group data element are updated automatically.&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;That is, we don&amp;rsquo;t need to have a line like, &lt;code&gt;d3.select(this).data = d&lt;/code&gt; within the &lt;code&gt;.each(...)&lt;/code&gt; call. For more on mutable objects see part 1 of this series.&lt;/span&gt; 
&lt;/p&gt;

&lt;p&gt;We then call &lt;code&gt;setCoordsData(d)&lt;/code&gt; to update the location of the rectangles in the group. The drag event &lt;code&gt;end&lt;/code&gt;s by undoing some of the styling that we added at the beginning.&lt;/p&gt;

&lt;h3 id=&#34;resizing:648b6abe57ff61375f3b845700219895&#34;&gt;Resizing&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;resizeRect&lt;/code&gt; sub-method is used to drag and resize the rectangle group. It was a whole lot of fun because the new rectangle coordinates depend on the corner on which the user clicks. Two examples of these delightful coordinate changes can be seen in &lt;code&gt;getDragCorners&lt;/code&gt;, a helper function. They account for both 1.) whether the mouse has exited the svg and 2.) whether the rectangle has been dragged back on top of itself.&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;For example, when the bottom-left corner is dragged so that it is the top-right corner&lt;/span&gt; 
&lt;/p&gt;

&lt;p&gt;The main code in &lt;code&gt;makeContainer&lt;/code&gt; follows the now-familiar pattern to specify a drag behavior.&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; resizeRect() {
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Resize the rectangle by dragging the corners&lt;/span&gt;

  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; getDragCorners() {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; {
      topleft&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; (d, bb0, m) {
        d.x &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.max(&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.min(bb0.x &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; bb0.width, m[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]));
        d.y &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.max(&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.min(bb0.y &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; bb0.height, m[&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;]));
        d.w &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; (m[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.min(&lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.abs(self.options.w &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; d.x), &lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.abs(bb0.x &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; bb0.width &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; m[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;])) &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; d.w;
        d.h &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; (m[&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.min(&lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.abs(self.options.h &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; d.y), &lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.abs(bb0.y &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; bb0.height &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; m[&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;])) &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; d.h;
      },

      topright&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; (d, bb0, m) {
        d.x &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.max(&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.min(bb0.x, m[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]));
        d.y &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.max(&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.min(bb0.y &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; bb0.height, m[&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;]));
        d.w &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; (m[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.min(&lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.abs(self.options.w &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; d.x), &lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.abs(bb0.x &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; m[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;])) &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; d.w;
        d.h &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; (m[&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.min(&lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.abs(self.options.h &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; d.y), &lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.abs(bb0.y &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; bb0.height &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; m[&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;])) &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; d.h;
      },

      botleft&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; (d, bb0, m) {...},

      botright&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; (d, bb0, m) {...}
    };
  }

  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; makeContainer &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; (id) {
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Make a container, which depends on the corner (specified by `id`)&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; dragCorners, cursor, bb0;

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Get the correct transformation function&lt;/span&gt;
    dragCorners &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; getDragCorners()[id];
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Get the correct cursor&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (contains([&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;topleft&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;botright&amp;#39;&lt;/span&gt;], id)) {
      cursor &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;nwse-resize&amp;#39;&lt;/span&gt;;
    } &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;else&lt;/span&gt; {
      cursor &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;nesw-resize&amp;#39;&lt;/span&gt;;
    }

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; start &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; () {
      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Set the present group to be active&lt;/span&gt;
      self.setActive(groupClass, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;false&lt;/span&gt;);
      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Get the active groups&lt;/span&gt;
      activeG &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; d3.selectAll(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;g.active&amp;#39;&lt;/span&gt;);
      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Get the initial Bounding Box&lt;/span&gt;
      bb0 &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; r.node().getBBox();
      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Display correct cursor tip&lt;/span&gt;
      self.svg.style(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;cursor&amp;#39;&lt;/span&gt;, cursor);
    }

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; drag &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; () {
      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Mouse position&lt;/span&gt;
      m &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; d3.mouse(self.zoomG.node());
      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Update parameters depending on&lt;/span&gt;
      dragCorners(g.datum(), bb0, m);
      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Set the coordinates&lt;/span&gt;
      setCoordsData(g.datum());
    }

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ....EXCLUDING CODE:&lt;/span&gt;
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//... end() and make container&lt;/span&gt;
  }
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//... Return Make drag containers for each &lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;makeContainer&lt;/code&gt; method requires an argument, &lt;code&gt;id&lt;/code&gt;, which specifies the corner for which the behavior will apply. With this info the method can get the correct entry in &lt;code&gt;makeDragBehavior&lt;/code&gt;, which will determine how the group data is updated. The only other thing that is idiosyncratic across corners is the correct cursor styling.&lt;/p&gt;

&lt;p&gt;In &lt;code&gt;makeRectDrag&lt;/code&gt; we can then specify the behavior on a given corner (e.g. the topleft) by writing something along the lines of:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;d3.select(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;rect.topleft&amp;#39;&lt;/span&gt;)
  .call(resize.makeContainer(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;topleft&amp;#39;&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&#34;odds-and-ends:648b6abe57ff61375f3b845700219895&#34;&gt;Odds and Ends&lt;/h2&gt;

&lt;h3 id=&#34;handling-active-rectangle-groups:648b6abe57ff61375f3b845700219895&#34;&gt;Handling Active Rectangle Groups&lt;/h3&gt;

&lt;p&gt;Here I&amp;rsquo;m going to discuss the method that handles this designation. When adding, moving, or resizing a rectangle we&amp;rsquo;ve called the &lt;code&gt;setActive&lt;/code&gt; method. Let&amp;rsquo;s discuss exactly what that does.&lt;/p&gt;

&lt;p&gt;Here is the code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;SVGCanvas.prototype.setActive &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; (id, force_clear &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;false&lt;/span&gt;) {
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Sets class to active for selected groups.&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; deactivate &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;false&lt;/span&gt;;

  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// When should all other groups be deactivated?&lt;/span&gt;
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//  1.A If the ctrl key is not pressed&lt;/span&gt;
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//  1.B If the present element isn&amp;#39;t already active&lt;/span&gt;
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//  (Use De Morgan&amp;#39;s Rules for this one.)&lt;/span&gt;
  deactivate &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; deactivate &lt;span style=&#34;color: #666666&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;!&lt;/span&gt;(d3.event.sourceEvent.ctrlKey &lt;span style=&#34;color: #666666&#34;&gt;||&lt;/span&gt; d3.selectAll(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;g.&amp;#39;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; id).classed(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;active&amp;#39;&lt;/span&gt;));
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//  2. If we didn&amp;#39;t force it to be.&lt;/span&gt;
  deactivate &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; deactivate &lt;span style=&#34;color: #666666&#34;&gt;||&lt;/span&gt; force_clear;
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// If any of these conditions met, clear the active elements.&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (deactivate) {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.svg.selectAll(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;g.active&amp;#39;&lt;/span&gt;).classed(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;active&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;false&lt;/span&gt;);
  }

  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Add &amp;#39;active&amp;#39; class to any &amp;#39;g&amp;#39; element with id = id passed.&lt;/span&gt;
  d3.selectAll(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;g.&amp;#39;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; id).classed(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;active&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;true&lt;/span&gt;);
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;There are two parts:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Determine if the &amp;ldquo;active&amp;rdquo; designation should be removed from the groups that are currently &amp;ldquo;active&amp;rdquo;. Removal depends on:

&lt;ul&gt;
&lt;li&gt;Whether the &lt;code&gt;ctrl&lt;/code&gt; key is pressed (don&amp;rsquo;t remove if it is).&lt;/li&gt;
&lt;li&gt;If we&amp;rsquo;re clicking an already-active rectangle.&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;And &lt;code&gt;ctrl&lt;/code&gt; is not clicked.&lt;/span&gt; 
 Again, this halts removal.&lt;/li&gt;
&lt;li&gt;If we&amp;rsquo;ve&amp;hellip;uh&amp;hellip;forced a removal via the argument &lt;code&gt;force_clear&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Add the &amp;ldquo;active&amp;rdquo; designation to the &lt;code&gt;&amp;lt;g&amp;gt;&lt;/code&gt; element that has class &lt;code&gt;id&lt;/code&gt;. Given the way in which &lt;code&gt;id&lt;/code&gt; is used in the current code, there will be a unique &lt;code&gt;&amp;lt;g&amp;gt;&lt;/code&gt; element with this class.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;delete-and-other-keydown-events:648b6abe57ff61375f3b845700219895&#34;&gt;&amp;ldquo;Delete&amp;rdquo; and Other Keydown Events&lt;/h3&gt;

&lt;p&gt;We created another new prototype method (&lt;code&gt;SVGCanvas.keydownEventHandlers&lt;/code&gt;) that will serve to listen for keydown events. In the &lt;code&gt;SVGCanvas&lt;/code&gt; constructor we attach this behavior with the line &lt;code&gt;d3.select(&#39;body&#39;).on(&#39;keydown&#39;, this.keydownEventHandlers);&lt;/code&gt;. Notice that the behavior is attached to the &lt;em&gt;body&lt;/em&gt; element of the html.&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;SVGCanvas.prototype.keydownEventHandlers &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; () {
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Event handler for keydown events&lt;/span&gt;

  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Press &amp;#39;Delete&amp;#39; to remove all active groups.&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (d3.event.key &lt;span style=&#34;color: #666666&#34;&gt;===&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;Delete&amp;#39;&lt;/span&gt;) {
    d3.selectAll(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;g.active&amp;#39;&lt;/span&gt;).remove();
  }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;A leading example of this sort of behavior involves deleting all &amp;ldquo;active&amp;rdquo; rectangle groups when the delete key is pressed. This can be done easily by checking if the pressed key is &lt;code&gt;&#39;Delete&#39;&lt;/code&gt; then removing all &lt;code&gt;&amp;lt;g&amp;gt;&lt;/code&gt; elements with class &lt;code&gt;active&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;modified-zoom-and-pan-behavior:648b6abe57ff61375f3b845700219895&#34;&gt;Modified Zoom-and-Pan Behavior&lt;/h3&gt;

&lt;p&gt;In part 2 of this series I toyed around with ways of ensuring that our &amp;ldquo;drawing&amp;rdquo; doesn&amp;rsquo;t venture too far off of the &lt;code&gt;&amp;lt;svg&amp;gt;&lt;/code&gt; element. For example, if we zoom in, move the mouse, and zoom back out we would like to be viewing the same drawing.&lt;/p&gt;

&lt;p&gt;I was never completely satisfied with the &amp;ldquo;solution&amp;rdquo; from part 2 (a sometimes-jerky transition back to square one). Now I think I&amp;rsquo;ve found a superior alternative.&lt;/p&gt;

&lt;p&gt;In short, any time a zoom or pan event occurs, we&amp;rsquo;re going to call a function that checks whether the proposed &lt;code&gt;d3.event.transform&lt;/code&gt; would transform us out of the &lt;code&gt;&amp;lt;svg&amp;gt;&lt;/code&gt;. If it would, then the transform is modified so that we stick at the boundary. The principles underlying the code are quite similar to those used to check whether we were resizing or moving the rectangle out of bounds.&lt;/p&gt;

&lt;p&gt;The new function is called &lt;code&gt;checkBounds&lt;/code&gt; and it is contained within the &lt;code&gt;SVGCanvas.makeZoomPan&lt;/code&gt; method. It basically consists in testing a lot of boundary conditions and modifying the transform accordingly.&lt;/p&gt;

&lt;p&gt;An example of the new behavior is that it is impossible to pan when completely zoomed out; panning would only drag in the areas that are off the svg.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:648b6abe57ff61375f3b845700219895&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;There are still a lot of drawing features that could be added. For example, it would be nice to have a way to undo/redo actions and select elements with a lasso-like tool.&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;To implement undo/redo we could create a &amp;ldquo;history&amp;rdquo; of past actions. For each action (e.g. add, resize, move, delete) we could create a sub-method that undoes the action. At the end of each action, then, we&amp;rsquo;d append this &amp;ldquo;undo&amp;rdquo; sub-method to the undo history.&lt;/span&gt; 
 We could also use the code that we&amp;rsquo;ve just created for rectangles as a basis for adding additional shapes.&lt;/p&gt;

&lt;p&gt;At this point, however, we have the minimum &lt;em&gt;drawing&lt;/em&gt; functionality that will be needed to carry out the application that I have in mind. In the next two posts I&amp;rsquo;m going to move to thinking of ways to add and extract data from the drawing. In particular, I&amp;rsquo;m going to be interested in specifying and viewing bounding boxes around elements of printed tables from (for example) the &lt;a href=&#34;https://babel.hathitrust.org/cgi/pt?id=uc2.ark:/13960/t2h70nf5h;view=1up;seq=6;size=75&#34;&gt;Census of Manufacturers&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Scraping Dynamic Web Content</title>
      <link>https://michaelwooley.github.io/posts/scrape-dynamic-1/</link>
      <pubDate>Mon, 11 Sep 2017 20:49:59 -0400</pubDate>
      
      <guid>https://michaelwooley.github.io/posts/scrape-dynamic-1/</guid>
      <description>

&lt;p&gt;I have a project in mind that is going to involve a lot of scraping from the websites of U.S. soccer leagues. While the leagues offer a lot of data about each match, we&amp;rsquo;re going to have to do some slightly non-standard tricks to get the data to load. Once that&amp;rsquo;s done we can use BeautifulSoup to extract the html elements.&lt;/p&gt;

&lt;h2 id=&#34;what-needs-to-happen:cb7684d834f952e94e1ed7987bec3a1a&#34;&gt;What Needs to Happen&lt;/h2&gt;

&lt;p&gt;Ultimately, I&amp;rsquo;m going to want to be scraping data from pages like &lt;a href=&#34;http://www.uslsoccer.com/newyorkredbullsii-fccincinnati-905766&#34;&gt;this&lt;/a&gt;. As you can see, this page provides a lot of information about a particular football game (Red Bulls II v. FC Cincinnati, 8/19/2017).&lt;/p&gt;

&lt;p&gt;Notice that there are elements that are loading as you open the page.&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;See, for example the green loading bars.&lt;/span&gt; 
 This provides an indication that all of the data is being loaded dynamically via javascript. Indeed, if you just requested this page (e.g. with the &lt;code&gt;requests&lt;/code&gt; module) you&amp;rsquo;d find that a lot of the data elements are missing. In short:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Problem 1.&lt;/em&gt; We need to get the javascript on the page to load.&lt;/p&gt;

&lt;p&gt;Now scroll to the top of the page and reload. Let the page sit for 10 seconds so that you are certain that the page is &amp;ldquo;loaded&amp;rdquo;. Now scroll down. Notice that the load bars come back up and all of that data needs to be called. It looks like this information only loads once we scroll down! This is a smart move by whoever made this page (there&amp;rsquo;s a lot of data on the page!) but it represents a problem for us:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Problem 2.&lt;/em&gt; Programmatically scroll the page so that the full page loads.&lt;/p&gt;

&lt;h2 id=&#34;the-code:cb7684d834f952e94e1ed7987bec3a1a&#34;&gt;The Code&lt;/h2&gt;

&lt;p&gt;Here&amp;rsquo;s the full code with a leading example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;selenium.webdriver.support.ui&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; WebDriverWait
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;selenium.webdriver.support&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; expected_conditions &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;as&lt;/span&gt; EC
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;selenium.webdriver.common.by&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; By
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;selenium&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; webdriver

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ScrapeDynamic&lt;/span&gt;(&lt;span style=&#34;color: #008000&#34;&gt;object&lt;/span&gt;):
    &lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;    ScrapeDynamic: Methods for scraping dynamic webpages.&lt;/span&gt;

&lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;    Information on:&lt;/span&gt;
&lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;        Basic concept: https://coderwall.com/p/vivfza/fetch-dynamic-web-pages-with-selenium&lt;/span&gt;
&lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;        Selenium Scrolling: https://stackoverflow.com/questions/20986631/how-can-i-scroll-a-web-page-using-selenium-webdriver-in-python&lt;/span&gt;
&lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;        Selenium waiting: http://selenium-python.readthedocs.io/waits.html&lt;/span&gt;

&lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;    Be sure to call ScrapeDynamic.stop() when you&amp;#39;re done to shut down the&lt;/span&gt;
&lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;        server thing&lt;/span&gt;
&lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;__init__&lt;/span&gt;(&lt;span style=&#34;color: #008000&#34;&gt;self&lt;/span&gt;, browserPath, browser&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;phantom&amp;#39;&lt;/span&gt;):
        &lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;        Input:&lt;/span&gt;
&lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;            - browserPath: Path to browser .exe&lt;/span&gt;
&lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;            - browser: Browser to use [&amp;#39;phantom&amp;#39;, &amp;#39;firefox&amp;#39;]. (default=&amp;#39;phantom&amp;#39;) (Add later)&lt;/span&gt;
&lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;        Returns:&lt;/span&gt;
&lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;            A ScrapeDynamic object.&lt;/span&gt;
&lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;# Start the WebDriver and load the page&lt;/span&gt;
        &lt;span style=&#34;color: #008000&#34;&gt;self&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;wd &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; webdriver&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;PhantomJS(executable_path &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; BrowserPath)

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;getUrl&lt;/span&gt;(&lt;span style=&#34;color: #008000&#34;&gt;self&lt;/span&gt;, url, selector):
        &lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;        Retrieve page source of dynamic webpage. Waits until `selector` loads to&lt;/span&gt;
&lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;            return. Automatically scrolls to bottom of page to ensure that all&lt;/span&gt;
&lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;            JS loads.&lt;/span&gt;

&lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;        Inputs:&lt;/span&gt;
&lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;            - url: website url&lt;/span&gt;
&lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;            - selector: CSS selector&lt;/span&gt;

&lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;        Returns:&lt;/span&gt;
&lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;            Page source (i.e. suitable for BeautifulSoup).&lt;/span&gt;
&lt;span style=&#34;color: #BA2121; font-style: italic&#34;&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;# Begin to retrieve the URL&lt;/span&gt;
        &lt;span style=&#34;color: #008000&#34;&gt;self&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;wd&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;get(url)
        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;# Scroll to bottom to page so that it will load all elements&lt;/span&gt;
        &lt;span style=&#34;color: #008000&#34;&gt;self&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;wd&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;execute_script(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;window.scrollTo(0, document.body.scrollHeight);&amp;quot;&lt;/span&gt;)

        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;# Wait for the dynamically loaded elements to show up&lt;/span&gt;
        WebDriverWait(&lt;span style=&#34;color: #008000&#34;&gt;self&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;wd, &lt;span style=&#34;color: #666666&#34;&gt;10&lt;/span&gt;)&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;until(
                EC&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;visibility_of_element_located((By&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;CSS_SELECTOR, selector)))

        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;self&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;wd&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;page_source

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;stop&lt;/span&gt;(&lt;span style=&#34;color: #008000&#34;&gt;self&lt;/span&gt;):
        &lt;span style=&#34;color: #008000&#34;&gt;self&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;wd&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;quit()


&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color: #19177C&#34;&gt;__name__&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;:
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;bs4&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; BeautifulSoup

    BrowserPath &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;C:/Program Files/PhantomJS/bin/phantomjs.exe&amp;#39;&lt;/span&gt; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;# Path to browser .exe&lt;/span&gt;
    URL &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;http://www.uslsoccer.com/newyorkredbullsii-fccincinnati-905766&amp;#39;&lt;/span&gt; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;# URL to retrieve&lt;/span&gt;
    selector &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;table.Opta-Striped.Opta-Squad&amp;#39;&lt;/span&gt; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;# CSS element to wait for&lt;/span&gt;

    R &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; ScrapeDynamic(BrowserPath)
    html_page &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; R&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;getUrl(URL, selector)
    R&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;stop()

    soup &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; BeautifulSoup(html_page, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;lxml&amp;#39;&lt;/span&gt;)
    element &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; soup&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;select(selector)
    &lt;span style=&#34;color: #008000&#34;&gt;print&lt;/span&gt;(element[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;prettify()[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color: #666666&#34;&gt;1000&lt;/span&gt;])
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The basic idea is to Programmatically launch and control a web browser. We init the &lt;code&gt;ScrapeDynamic&lt;/code&gt; object by launching a browser.&lt;/p&gt;

&lt;p&gt;In the &lt;code&gt;ScrapeDynamic.getURL&lt;/code&gt; we request a particular web page (&lt;code&gt;self.wd.get(url)&lt;/code&gt;). Here we&amp;rsquo;re really just opening the page like you would if you were surfing yourself.&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;With a few modifications you can run this code with Firefox and the there the fact that we&amp;rsquo;re just opening the page becomes really apparent.&lt;/span&gt; 
 In the next line we get the page to scroll to the bottom by executing one line of JavaScript. This takes care of problem 2. The only thing that we have to do is check to see if the information has loaded. This is where the &lt;code&gt;selector&lt;/code&gt; element comes in. The idea behind doing this is that the code is going to be searching for this selector. Once it spots this selector in the html source the method will return. In the example script I&amp;rsquo;ve passed CSS selector that corresponds to the table containing information about the players on each roster. Since I&amp;rsquo;m mostly going to be interested in this data I want to make sure that it has loaded before the method returns the output.&lt;/p&gt;

&lt;h3 id=&#34;usage:cb7684d834f952e94e1ed7987bec3a1a&#34;&gt;Usage&lt;/h3&gt;

&lt;p&gt;To use the code you&amp;rsquo;ll:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Initiate a &lt;code&gt;ScrapeDynamic&lt;/code&gt; object with the path to your web browser.&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;For more info on dependencies see below.&lt;/span&gt; 
&lt;/li&gt;
&lt;li&gt;Call the &lt;code&gt;ScrapeDynmic.getURL&lt;/code&gt; method with arguments:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;URL&lt;/code&gt;: The url of the page to be scraped.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;selector&lt;/code&gt;: A CSS selector discussed more below.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Tidy up: Shut down the &lt;code&gt;ScrapeDynamic&lt;/code&gt; object.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The &lt;code&gt;ScrapeDynamic.getURL&lt;/code&gt; method will return the full html source of the page. This output is essentially what we would get if we scraped a static page with the &lt;code&gt;requests&lt;/code&gt; module. We can then pass this on to a tool like &lt;code&gt;BeautifulSoup&lt;/code&gt; to parse the elements.&lt;/p&gt;

&lt;p&gt;By doing all of this setup once, we can save time when, for example, we&amp;rsquo;ll want to scrape several pages.&lt;/p&gt;

&lt;h3 id=&#34;dependencies:cb7684d834f952e94e1ed7987bec3a1a&#34;&gt;Dependencies&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;ve only tested this code on &lt;strong&gt;Windows 10&lt;/strong&gt; at the moment. You can see that there are certain features that assume a Windows-type system (e.g. the need for an executable argument).&lt;/p&gt;

&lt;p&gt;In terms of python packages you&amp;rsquo;ll need to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pip install selenium&lt;/code&gt; (&lt;a href=&#34;http://selenium-python.readthedocs.io/&#34;&gt;&lt;em&gt;Selenium&lt;/em&gt;&lt;/a&gt;) Use this to set up a &amp;ldquo;webdriver&amp;rdquo;, which can take commands and send them to the browser.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pip install bs4&lt;/code&gt; (&lt;a href=&#34;https://www.crummy.com/software/BeautifulSoup/bs4/doc/&#34;&gt;&lt;em&gt;BeautifulSoup4&lt;/em&gt;&lt;/a&gt;) Needed for the example and to manipulate any of the output returned by the &lt;code&gt;getURL&lt;/code&gt; method.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For this I also used the &lt;a href=&#34;http://phantomjs.org/&#34;&gt;PhantomJS&lt;/a&gt; browser. It is nice because it is lightweight and designed for this sort of thing.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:cb7684d834f952e94e1ed7987bec3a1a&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;That&amp;rsquo;s it. In future posts I&amp;rsquo;ll put this code to work to gather my data. Tomorrow I&amp;rsquo;m going to return to my drawing app with a big update.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Drawing With D3.js Part 2: Zooming and Panning</title>
      <link>https://michaelwooley.github.io/posts/drawing-2/</link>
      <pubDate>Thu, 07 Sep 2017 09:33:59 -0400</pubDate>
      
      <guid>https://michaelwooley.github.io/posts/drawing-2/</guid>
      <description>

&lt;p&gt;This post adds features to the drawing app that we started in &lt;a href=&#34;https://michaelwooley.github.io/posts/drawing-1&#34;&gt;part 1&lt;/a&gt;. In particular, we&amp;rsquo;re going to make it easy to zoom and pan the canvas. Again D3.js will simplify our job substantially. In fact, there is a built-in feature/command (&lt;a href=&#34;https://github.com/d3/d3-zoom&#34;&gt;d3-zoom&lt;/a&gt;) that would ordinarily allow us to zoom with a scrolling/pinching gesture and pan with a click-and-drag gesture. The main wrinkle that we&amp;rsquo;re going to encounter is that the click-and-drag gesture is already taken: we click and drag to add rectangles. Our job, then, will consist in figuring out a way to juggle competing event listeners.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s what we&amp;rsquo;re going to create:&lt;/p&gt;

&lt;figure&gt;
&lt;label for=&#34;main-sample&#34; class=&#34;margin-toggle&#34;&gt;&amp;#8853;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;main-sample&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;marginnote&#34;&gt;&lt;code&gt;Click + drag&lt;/code&gt; &amp;#x2192; Add rectangle.&lt;br&gt;&lt;code&gt;Shift + Click + Drag&lt;/code&gt; &amp;#x2192; Pan Canvas.&lt;br&gt;&lt;code&gt;scroll&lt;/code&gt; &amp;#x2192; Zoom.&lt;br&gt;See the full sample code at this  &lt;a href=&#34;https://gist.github.com/michaelwooley/7a1727322376caed3bc13e494a03867c&#34;&gt;gist&lt;/a&gt;.&lt;/span&gt;
&lt;div class=&#34;sample-div&#34;&gt;&lt;/div&gt;
&lt;/figure&gt;


&lt;p&gt;As you can see from the demo, we&amp;rsquo;re going to implement canvas panning by making it into a &lt;code&gt;Shift + Click + Drag&lt;/code&gt; gesture. To do this, we&amp;rsquo;re going to add some new code and reorganize some of our earlier code. In particular we&amp;rsquo;ll:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Introduce a zoom &lt;code&gt;&amp;lt;g&amp;gt;&lt;/code&gt;roup element that nests all elements that are subsequently added to the canvas. We&amp;rsquo;ll carry out zooming and panning by transforming this element.&lt;/li&gt;
&lt;li&gt;Add a &lt;code&gt;d3.zoom&lt;/code&gt; behavior to the canvas. We&amp;rsquo;ll need to turn on the scroll gestures and turn off event listeners for the pan behavior.&lt;/li&gt;
&lt;li&gt;Modify the &lt;code&gt;drag&lt;/code&gt; behavior on the canvas to route drag gestures. If the shift key is pressed, then the canvas should pan. If it is not, then a new rectangle should be created.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let&amp;rsquo;s get to it.&lt;/p&gt;

&lt;h2 id=&#34;restructuring-the-event-listeners:e218a3c29df923eed379019aa812cdd9&#34;&gt;Restructuring the Event Listeners&lt;/h2&gt;

&lt;p&gt;In the previous post I added an event listener for a click-and-drag gesture using off-the-shelf methods from d3. For this post I&amp;rsquo;m going to need to dig a bit deeper into these methods to get the behavior that I want.&lt;/p&gt;

&lt;h3 id=&#34;drag-routing:e218a3c29df923eed379019aa812cdd9&#34;&gt;Drag Routing&lt;/h3&gt;

&lt;p&gt;Recall that we specified a drag behavior via something like this:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.svg.call(
  d3.drag()
  .on(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;start&amp;#39;&lt;/span&gt;, self.dragBehavior.start)
  .on(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;drag&amp;#39;&lt;/span&gt;, self.dragBehavior.drag)
  .on(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;end&amp;#39;&lt;/span&gt;, self.dragBehavior.end)
);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In the previous post we specified that our &lt;code&gt;dragBehavior&lt;/code&gt; methods were from &lt;code&gt;SVGCAnvas.addRect&lt;/code&gt;. That is, at the start of the drag we called the code to create the rectangle and as we dragged the the &lt;code&gt;.drag&lt;/code&gt; method changed the rectangle dimensions.&lt;/p&gt;

&lt;p&gt;For this post we need to differentiate between a &amp;ldquo;vanilla drag&amp;rdquo; and a drag in which the shift key is compressed. To do this we&amp;rsquo;ll create an additional set of methods (stored in &lt;code&gt;SVGCanvas.dragBehavior&lt;/code&gt;) that will &lt;em&gt;route&lt;/em&gt; the drag behavior. Here&amp;rsquo;s some pseudo-code demonstrating the basic idea:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;dragBehavior &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt;() {
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; ( Detect no shift key ) {
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Add and modify a rectangle&lt;/span&gt;
  }
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; ( Detect shift key ) {
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Pan the Canvas&lt;/span&gt;
  }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In short, we&amp;rsquo;re nesting an event listener in an event listener. The exact code is as follows:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 1 &lt;/span&gt;SVGCanvas.prototype.makeDragBehavior &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt;() {
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 2 &lt;/span&gt;  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; self &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 3 &lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 4 &lt;/span&gt;  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; start &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt;() {
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 5 &lt;/span&gt;    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color: #666666&#34;&gt;!&lt;/span&gt;d3.event.sourceEvent.shiftKey) {
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 6 &lt;/span&gt;      self.addRect.start();
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 7 &lt;/span&gt;    }
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 8 &lt;/span&gt;    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (d3.event.sourceEvent.shiftKey) {
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 9 &lt;/span&gt;      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;null&lt;/span&gt;;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;10 &lt;/span&gt;    }
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;11 &lt;/span&gt;  }
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;12 &lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;13 &lt;/span&gt;  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; drag &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt;() {
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;14 &lt;/span&gt;    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color: #666666&#34;&gt;!&lt;/span&gt;(self.Rect.r &lt;span style=&#34;color: #666666&#34;&gt;===&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;null&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;!&lt;/span&gt;(d3.event.sourceEvent.shiftKey)) {
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;15 &lt;/span&gt;      self.addRect.drag();
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;16 &lt;/span&gt;    }
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;17 &lt;/span&gt;    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (d3.event.sourceEvent.shiftKey) {
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;18 &lt;/span&gt;      self.zoomPan.pan();
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;19 &lt;/span&gt;    }
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;20 &lt;/span&gt;  }
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;21 &lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;22 &lt;/span&gt;  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; end &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt;() {  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color: #666666&#34;&gt;!&lt;/span&gt;(self.Rect.r &lt;span style=&#34;color: #666666&#34;&gt;===&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;null&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;23 &lt;/span&gt;  &lt;span style=&#34;color: #666666&#34;&gt;!&lt;/span&gt;(d3.event.sourceEvent.shiftKey)) { self.addRect.end(); } &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;24 &lt;/span&gt;  (d3.event.sourceEvent.shiftKey) { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;null&lt;/span&gt;; } }
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;25 &lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;26 &lt;/span&gt;  self.dragBehavior &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; {
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;27 &lt;/span&gt;    start&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; start,
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;28 &lt;/span&gt;    drag&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; drag,
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;29 &lt;/span&gt;    end&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; end
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;30 &lt;/span&gt;  };
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;31 &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The &lt;code&gt;d3.event.sourceEvent.shiftKey&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if the shift key is compressed.&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;There are a number of other such properties for the alt key, etc.&lt;/span&gt; 
 If the key is compressed, then&amp;ndash;in the &lt;code&gt;drag&lt;/code&gt; method&amp;ndash;we call a new method called &lt;code&gt;self.zoomPan.pan&lt;/code&gt;. This is the method that we will use to pan the canvas; it will be discussed further below. When defining the &lt;code&gt;drag&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; methods we have the additional condition &lt;code&gt;!(self.Rect.r === null)&lt;/code&gt;. This condition checks for an edge case.&lt;label for=&#34;null-rect&#34; class=&#34;margin-toggle&#34;&gt;&amp;#8853;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;null-rect&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;marginnote&#34;&gt;To be specific, the case arises if the user 1.) Clicks down while holding the shift key, 2.) releases the shift key but not the click, and 3.) drags. Without the condition the &lt;code&gt;addRect.drag&lt;/code&gt; method would either be called on the last rectangle created&amp;ndash;changing the coordinates of that rectangle&amp;ndash;or (in the case where no rectangles have been created) we would get an error.&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;As was the case with the &lt;code&gt;SVGCanvas.addRect&lt;/code&gt; methods, I have defined an enclosing method &lt;code&gt;SVGCanvas.makeDragBehavior&lt;/code&gt; in order to define the methods and set the context. This method will have to be called from the &lt;code&gt;SVGCanvas&lt;/code&gt; constructor function.&lt;/p&gt;

&lt;h3 id=&#34;zoom-listener:e218a3c29df923eed379019aa812cdd9&#34;&gt;Zoom Listener&lt;/h3&gt;

&lt;p&gt;The zoom listener is going to be less elaborate than the drag listener but we&amp;rsquo;ll still have to dig into the &lt;code&gt;d3.zoom&lt;/code&gt; api a bit. Here&amp;rsquo;s the code that we need to add to the &lt;code&gt;SVGCanvas&lt;/code&gt; constructor object:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 1 &lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.svg.call(
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 2 &lt;/span&gt;    d3.zoom()
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 3 &lt;/span&gt;    .scaleExtent([&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;10&lt;/span&gt;])
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 4 &lt;/span&gt;    .on(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;zoom&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.zoomPan.zoom)
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 5 &lt;/span&gt;  )
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 6 &lt;/span&gt;  .on(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;mousedown.zoom&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;null&lt;/span&gt;)  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// For rodent lovers&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 7 &lt;/span&gt;  .on(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;mousemove.zoom&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;null&lt;/span&gt;)
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 8 &lt;/span&gt;  .on(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;mouseup.zoom&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;null&lt;/span&gt;)
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 9 &lt;/span&gt;  .on(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;touchstart.zoom&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;null&lt;/span&gt;) &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// For our smartphone-toting friends&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;10 &lt;/span&gt;  .on(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;touchmove.zoom&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;null&lt;/span&gt;)
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;11 &lt;/span&gt;  .on(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;touchend.zoom&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;null&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As with the &lt;code&gt;drag&lt;/code&gt; behavior, we add a &lt;code&gt;call&lt;/code&gt; to the &lt;code&gt;svg&lt;/code&gt; element. Lines 2-4 specify a &amp;ldquo;normal&amp;rdquo; zoom operation. That is, it attaches a zoom behavior with &lt;code&gt;d3.zoom()&lt;/code&gt;. With &lt;code&gt;.scaleExtent([1, 10])&lt;/code&gt; we modify the zoom behavior so that the minimal zoom is &amp;ldquo;1&amp;rdquo; and the maximal zoom is &amp;ldquo;10&amp;rdquo;.&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;We&amp;rsquo;ll get into what exactly &amp;ldquo;1&amp;rdquo; and &amp;ldquo;10&amp;rdquo; mean below. In short, this is the number that enters the &lt;code&gt;scale(#)&lt;/code&gt; specification in the &lt;code&gt;transform&lt;/code&gt; attribute.&lt;/span&gt; 
 Finally, line 4 attaches a method &lt;code&gt;this.zoomPan.zoom&lt;/code&gt; (discussed below) that will be used to zoom in and out.&lt;/p&gt;

&lt;p&gt;In lines 6-11 we are basically undoing a lot of the default behavior of &lt;code&gt;d3.zoom&lt;/code&gt;. Usually, &lt;code&gt;d3.zoom&lt;/code&gt; is a method for both &lt;em&gt;panning&lt;/em&gt; and &lt;em&gt;zooming&lt;/em&gt;. We need to override the default panning behavior in order to route drag events to our homespun drag behavior. Let&amp;rsquo;s break down line 6 in detail. In general, the &lt;code&gt;.on([event], [callback])&lt;/code&gt; method specifies what should occur (the callback) whenever an event is detected on an element. Here, &lt;code&gt;mousedown.zoom&lt;/code&gt; is a special sort of event: a &amp;ldquo;mousedown&amp;rdquo; (i.e. downward click) associated with the zoom event (which we&amp;rsquo;ve just defined). The default behavior in this case is to start a canvas pan that would override all other mousedown events. Here, however, we specify the callback to be &lt;code&gt;null&lt;/code&gt;. That is, we specify that these events should be ignored. Each of lines 7-11 similarly &lt;code&gt;null&lt;/code&gt;ify other event listeners associated with &lt;code&gt;d3.zoom&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;the-zoom-group-and-transformations:e218a3c29df923eed379019aa812cdd9&#34;&gt;The Zoom Group and Transformations&lt;/h2&gt;

&lt;p&gt;In this section I&amp;rsquo;m going to set up some new infrastructure to make zooming simple. We&amp;rsquo;re going to start out by wrapping everything in a &lt;code&gt;&amp;lt;g&amp;gt;&lt;/code&gt;roup element. By manipulating the &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform&#34;&gt;&lt;code&gt;transform&lt;/code&gt;&lt;/a&gt; attribute of the &lt;code&gt;&amp;lt;g&amp;gt;&lt;/code&gt; element we&amp;rsquo;ll be able to translate, rotate, scale, or skew all of the elements contained in the &lt;code&gt;&amp;lt;g&amp;gt;&lt;/code&gt; element &lt;em&gt;simultaneously&lt;/em&gt;. Next, we&amp;rsquo;re going to need to make some modifications to account for the fact that transforming the canvas messes up our coordinate system. We&amp;rsquo;re going to need to modify our method for detecting the mouse position&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;This is the previously-trivial &lt;code&gt;mouseOffset&lt;/code&gt; method.&lt;/span&gt; 
 to account for this.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;aside-g-transform-transpose-30-2-scale-2:e218a3c29df923eed379019aa812cdd9&#34;&gt;Aside: &lt;code&gt;&amp;lt;g transform=&amp;quot;transpose(30,2) scale(2)&amp;quot;&amp;gt;&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;While I briefly introduced the &lt;code&gt;&amp;lt;g&amp;gt;&lt;/code&gt; element in the last post, I didn&amp;rsquo;t do anything with it. &lt;code&gt;&amp;lt;g&amp;gt;&lt;/code&gt; elements are sort of like &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;s for SVGs. They don&amp;rsquo;t really do anything, they just organize elements into, well, groups. Groups are uniquely well-suited for transformations. Here is the basic gameplan: We&amp;rsquo;ll define a group and place all of our other elements within it. For example:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;svg&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;height&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;250&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;width&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;250&amp;quot;&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;g&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;zoom-group&amp;quot;&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;rect&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;94&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;112&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;width&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;160&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;height&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;120&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;rect-main&amp;quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;rect&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;rect&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;186&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;178&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;width&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;144&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;height&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;76&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;rect-main&amp;quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;rect&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;rect&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;132&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;148&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;width&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;88&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;height&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;60&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;rect-main&amp;quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;rect&lt;/span&gt;&amp;gt;
  &amp;lt;/&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;g&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;svg&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Now, we can translate, scale, skew, or rotate all of these elements &lt;em&gt;simultaneously&lt;/em&gt; by manipulating the &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform&#34;&gt;&lt;code&gt;transform&lt;/code&gt;&lt;/a&gt; attribute of &lt;code&gt;&amp;lt;g class=&amp;quot;zoom-group&amp;quot;&amp;gt;&lt;/code&gt;. Consider:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;svg&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;height&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;250&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;width&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;250&amp;quot;&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;g&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;zoom-group&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;transform&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;translate(-128,-80) scale(2)&amp;quot;&lt;/span&gt;&amp;gt;...&amp;lt;/&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;g&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;svg&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Here, we&amp;rsquo;ve:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Shifted/&lt;code&gt;translate&lt;/code&gt;d the canvas:

&lt;ul&gt;
&lt;li&gt;128 units to the &lt;em&gt;right&lt;/em&gt; (i.e. leftward mouse movement).&lt;/li&gt;
&lt;li&gt;80 units to the &lt;em&gt;down&lt;/em&gt; (i.e. upward mousemovemt).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Zoomed/&lt;code&gt;scale&lt;/code&gt;d the canvas so that the elements inside the group are displayed at &lt;em&gt;twice&lt;/em&gt; their ordinary size.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;figure&gt;
&lt;label for=&#34;g_transform&#34; class=&#34;margin-toggle&#34;&gt;&amp;#8853;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;g_transform&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;marginnote&#34;&gt;
    &lt;img src=&#34;https://michaelwooley.github.io/posts/drawing-2/media/g_transform.gif&#34;&gt;
    Panning and zooming affects all elements in the canvas. However, only the &lt;code&gt;transform&lt;/code&gt; attribute of the &lt;code&gt;&amp;lt;g&amp;gt;&lt;/code&gt; element changes. Notice that the &lt;code&gt;&amp;lt;rect&amp;gt;&lt;/code&gt; element does not change.
&lt;/span&gt;
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;transform&lt;/code&gt; attribute is quite powerful but also rather complicated. Refer to the &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform&#34;&gt;Mozilla reference page&lt;/a&gt; or this nice write-up by &lt;a href=&#34;https://www.sarasoueidan.com/blog/svg-coordinate-systems/&#34;&gt;Sara Soueidan&lt;/a&gt; for more information.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;zoom-group-implementation:e218a3c29df923eed379019aa812cdd9&#34;&gt;Zoom Group: Implementation&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s add a zoom group to the &lt;code&gt;SVGCanvas&lt;/code&gt; constructor:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; SVGCanvas(options) {
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Previous...&lt;/span&gt;

  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Canvas&lt;/span&gt;
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//// Make the main container SVG&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.svg &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; d3.select(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.options.addTo)
    .append(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;svg&amp;#39;&lt;/span&gt;)
    .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;height&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.options.h)
    .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;width&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.options.w)
    .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;class&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;display-svg&amp;#39;&lt;/span&gt;);
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//// Add border if requested  &amp;lt;= NOT INCLUDED IN ZOOM GROUP&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.options.addBorderRect) {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.svg.append(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;rect&amp;#39;&lt;/span&gt;)
      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;height&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.options.h)
      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;width&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.options.w)
      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;stroke&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;black&amp;#39;&lt;/span&gt;)
      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;stroke-width&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;4&lt;/span&gt;)
      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;opacity&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;0.25&lt;/span&gt;)
      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;fill-opacity&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;0.0&lt;/span&gt;)
      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;class&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;border-rect&amp;#39;&lt;/span&gt;);
  }
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//// Add zoom and pan group&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.zoomG &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.svg
    .append(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;g&amp;#39;&lt;/span&gt;)
    .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;class&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;zoom-group&amp;#39;&lt;/span&gt;);

  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Rectangles&lt;/span&gt;
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// More...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Here, we&amp;rsquo;ve append a &lt;code&gt;&amp;lt;g&amp;gt;&lt;/code&gt; element to &lt;code&gt;this.svg&lt;/code&gt; and defined a new property, &lt;code&gt;this.zoomG&lt;/code&gt;. Notice that we don&amp;rsquo;t include the border rectangle element in the zoom group. Thus, any transformations that are applied to the zoom group will not affect the border rectangle, which is what we want.&lt;/p&gt;

&lt;p&gt;We &lt;em&gt;do&lt;/em&gt; want the rectangles that we draw to be affected by the transformations, however. To do this, we need to modify the &lt;code&gt;SVGCanvas.addRect.start&lt;/code&gt; method so that the new &lt;code&gt;&amp;lt;rect&amp;gt;&lt;/code&gt; elements are appended to the zoom group element rather than the &lt;code&gt;&amp;lt;svg&amp;gt;&lt;/code&gt;. We can do this by changing line 11 below:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 1 &lt;/span&gt;SVGCanvas.prototype.makeAddRect &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt;() {
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 2 &lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Methods for adding rectangles to the svg.&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 3 &lt;/span&gt;  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; self &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 4 &lt;/span&gt;  start &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt;() {
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 5 &lt;/span&gt;    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//Add a rectangle&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 6 &lt;/span&gt;    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 1. Get mouse location in SVG&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 7 &lt;/span&gt;    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; m &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; self.mouseOffset();
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 8 &lt;/span&gt;    self.Rect.x0 &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; m.x;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 9 &lt;/span&gt;    self.Rect.y0 &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; m.y;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;10 &lt;/span&gt;    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 2. Make a rectangle&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;11 &lt;/span&gt;    self.Rect.r &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; self.zoomG &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// &amp;lt;= self.zoomG, NOT self.svg&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;12 &lt;/span&gt;      .append(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;g&amp;#39;&lt;/span&gt;)
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;13 &lt;/span&gt;      .append(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;rect&amp;#39;&lt;/span&gt;)
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;14 &lt;/span&gt;      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;x&amp;#39;&lt;/span&gt;, self.Rect.x0)
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;15 &lt;/span&gt;      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;y&amp;#39;&lt;/span&gt;, self.Rect.y0)
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;16 &lt;/span&gt;      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;width&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;)
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;17 &lt;/span&gt;      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;height&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;)
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;18 &lt;/span&gt;      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;class&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;rect-main&amp;#39;&lt;/span&gt;)
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;19 &lt;/span&gt;    ;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;20 &lt;/span&gt;  }
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;21 &lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;22 &lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// More ...&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;23 &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it!&lt;/p&gt;

&lt;h3 id=&#34;mouse-coordinates:e218a3c29df923eed379019aa812cdd9&#34;&gt;Mouse Coordinates&lt;/h3&gt;

&lt;p&gt;The main thing to be aware of here is that all of this panning and zooming business will mess with your attempts to detect where the mouse click occurs. The problem is twofold: First, you want to use the mouse position to specify the location of the added rectangles relative to a single, common coordinate system.&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;That is, a rectangle should have the same x/y and height/width attributes whether it is drawn at 2x zoom with a bunch of panning or 1x zoom.&lt;/span&gt; 
 Second, we want the information/drawing that appears on the screen to reflect whatever screwy, transformed coordinate system we&amp;rsquo;re currently working in.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;manual&lt;/em&gt; way of doing this is to get the mouse coordinates off of the &lt;code&gt;d3.event&lt;/code&gt; object and scale and shift them:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;SVGCanvas.prototype.mouseOffset &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt;() {
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; m &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; d3.event;
  m.x &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.transform.x &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; m.x) &lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.transform.k;
  m.y &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.transform.y &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; m.y) &lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.transform.k;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; m;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Here, &lt;code&gt;this.transform&lt;/code&gt; is an &lt;code&gt;SVGCanvas&lt;/code&gt; property (discussed below). The &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;k&lt;/code&gt; properties map to &lt;code&gt;transform=&amp;quot;translate(x, y) scale(k)&amp;quot;&lt;/code&gt; from the &lt;code&gt;&amp;lt;g&amp;gt;&lt;/code&gt; element.&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;I&amp;rsquo;m keeping this code around because it may come in handy later.&lt;/span&gt; 
&lt;/p&gt;

&lt;p&gt;We can do this coordinate transform &lt;em&gt;automatically&lt;/em&gt; by making use of the &lt;code&gt;d3.mouse&lt;/code&gt; method:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;SVGCanvas.prototype.mouseOffset &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt;() {
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; d3.mouse(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.zoomG.node());
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Here, an array (rather than object) is returned with entries &lt;code&gt;[x, y]&lt;/code&gt;. The coordinates are automatically transformed relative to the specified element: the zoom group &lt;code&gt;&amp;lt;g&amp;gt;&lt;/code&gt; (&lt;code&gt;this.zoomG&lt;/code&gt;) element. Notice that I have called &lt;code&gt;this.zoomG.node()&lt;/code&gt;. The &lt;code&gt;.node()&lt;/code&gt; method returns the HTML block corresponding to the zoom group element.&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;I still need to dig deeper into D3 to understand the reasoning behind why it is sometimes preferable to pass the node rather than the D3 object itself.&lt;/span&gt; 
&lt;/p&gt;

&lt;h2 id=&#34;zoom-and-pan-methods:e218a3c29df923eed379019aa812cdd9&#34;&gt;Zoom and Pan Methods&lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;ve seen that we can manipulate the canvas by manipulating the &lt;code&gt;transform&lt;/code&gt; attribute. Now we&amp;rsquo;re going to add methods and behaviors so that these manipulations will occur in response to user gestures.&lt;/p&gt;

&lt;p&gt;As with the &lt;code&gt;SVGCanvas.addRect&lt;/code&gt; methods from part 1, I&amp;rsquo;m going to specify zoom and pan methods in a sort-of hacky way. We&amp;rsquo;ll add a new property&amp;ndash;&lt;code&gt;SVGCanvas.zoomPan&lt;/code&gt;&amp;ndash;that will have methods for zooming and panning the canvas. Then we&amp;rsquo;ll add new behaviors to the canvas that call these methods.&lt;/p&gt;

&lt;h3 id=&#34;zoom-ing:e218a3c29df923eed379019aa812cdd9&#34;&gt;&lt;code&gt;Zoom&lt;/code&gt;ing&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s start out by defining what should happen on zoom. Below I&amp;rsquo;ve set up the basic structure of the &lt;code&gt;SVGCanvas&lt;/code&gt; method that defines both the zooming and panning function.&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;Notice that we again need to be careful about setting the context. We set &lt;code&gt;self = this&lt;/code&gt;, where &lt;code&gt;this&lt;/code&gt; is the &lt;code&gt;SVGCanvas&lt;/code&gt;.&lt;/span&gt; 
 The zoom function proper begins on line 6. In principle, this could be a one-liner. Among other things, a &lt;code&gt;zoom&lt;/code&gt; event will return information about the shifting and scaling that results from the event.&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;I&amp;rsquo;m still a bit murky on how this works.&lt;/span&gt; 
 That is, it will return an &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;k&lt;/code&gt; that we can use to specify the zoom group&amp;rsquo;s &lt;code&gt;transform&lt;/code&gt; attribute a la &lt;code&gt;translate(x, y) scale(k)&lt;/code&gt;. We can access this information via &lt;code&gt;d3.event.transform&lt;/code&gt;. We&amp;rsquo;ll store the information in the property &lt;code&gt;self.transform&lt;/code&gt; for later.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 1 &lt;/span&gt;SVGCanvas.prototype.makeZoomPan &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt;() {
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 2 &lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Defines zooming and panning behavior from zoom listener&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 3 &lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 4 &lt;/span&gt;  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; self &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 5 &lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 6 &lt;/span&gt;  zoom &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt;() {
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 7 &lt;/span&gt;    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// What should happen when the wheel is scrolled?&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 8 &lt;/span&gt;    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Register transformation from event&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 9 &lt;/span&gt;    self.transform &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; d3.event.transform;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;10 &lt;/span&gt;    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Modify `transform` property of zoom-group&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;11 &lt;/span&gt;    self.zoomG.attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;transform&amp;#39;&lt;/span&gt;, self.transform);
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;12 &lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;13 &lt;/span&gt;    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Go back to initial position if zoomed out.&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;14 &lt;/span&gt;    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (d3.event.transform.k &lt;span style=&#34;color: #666666&#34;&gt;===&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;) {
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;15 &lt;/span&gt;      self.zoomG
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;16 &lt;/span&gt;        .transition(d3.transition() &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Make movement less jerky&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;17 &lt;/span&gt;          .duration(&lt;span style=&#34;color: #666666&#34;&gt;100&lt;/span&gt;)              
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;18 &lt;/span&gt;          .ease(d3.easeLinear))
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;19 &lt;/span&gt;        .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;transform&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;translate(0,0) scale(1)&amp;#39;&lt;/span&gt;);
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;20 &lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;21 &lt;/span&gt;      self.transform.x &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;22 &lt;/span&gt;      self.transform.y &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;23 &lt;/span&gt;      self.transform.k &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;24 &lt;/span&gt;    }
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;25 &lt;/span&gt;  }
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;26 &lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;27 &lt;/span&gt;  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; pan &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt;() {
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;28 &lt;/span&gt;    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//...&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;29 &lt;/span&gt;  }
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;30 &lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;31 &lt;/span&gt;  self.zoomPan &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; {zoom&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; zoom, pan&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; pan};
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;32 &lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;33 &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;The next step is just to modify the &lt;code&gt;transform&lt;/code&gt; attribute of the zoom group (line 11). In version 4 of D3 we can simply pass &lt;code&gt;d3.event.transform&lt;/code&gt; as the argument and be done with it.&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;How does that work? Here&amp;rsquo;s my impression: The second argument of &lt;code&gt;self.zoomG.attr(...)&lt;/code&gt; requires a string. When we pass an object the parser will look to see if the object has a &lt;code&gt;.toString&lt;/code&gt; method. So, for example, if &lt;code&gt;h = 5&lt;/code&gt; then calling &lt;code&gt;h.toString()&lt;/code&gt; will return the character &amp;ldquo;5&amp;rdquo;. The &lt;code&gt;d3.event.transform.toString()&lt;/code&gt; method returns &lt;code&gt;&amp;quot;translate(&amp;quot; + this.x + &amp;quot;,&amp;quot; + this.y + &amp;quot;) scale(&amp;quot; + this.k + &amp;quot;)&amp;quot;&lt;/code&gt;. So, in short, if &lt;code&gt;d3.event.x = 5&lt;/code&gt;, &lt;code&gt;d3.event.y = 6&lt;/code&gt;, and &lt;code&gt;d3.event.k = 2&lt;/code&gt; we get &lt;code&gt;translate(5,6) scale(2)&lt;/code&gt;.&lt;/span&gt; 
 So the one-liner version of this is &lt;code&gt;self.zoomG.attr(&#39;transform&#39;, d3.event.transform)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s turn to the part beginning in line 14. The idea behind this block is to reset the canvas positioning whenever we&amp;rsquo;re zoomed out completely. In short, it tests whether the scale is 1 (the minimum scaling level from &lt;code&gt;.scaleExtent([1, 10])&lt;/code&gt;). If it is, we change the transform property of the zoom group element so that the translation is &lt;code&gt;(0,0)&lt;/code&gt; (i.e. no translation). In lines 16-18 we use &lt;a href=&#34;https://github.com/d3/d3-transition&#34;&gt;D3 transitions&lt;/a&gt; to make the canvas slide into the new position &lt;em&gt;quickly&lt;/em&gt; (in 100ms) but &lt;em&gt;gracefully&lt;/em&gt;. We then manually reset the properties of &lt;code&gt;self.transform&lt;/code&gt; to the specified coordinates.&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;In an earlier version of this code I tried resetting &lt;code&gt;self.transform&lt;/code&gt; by calling &lt;a href=&#34;https://github.com/d3/d3-zoom/blob/master/README.md#zoomTransform&#34;&gt;&lt;code&gt;d3.zoomTransform(this.zoomG.node())&lt;/code&gt;&lt;/a&gt;. This produced some odd behavior that I won&amp;rsquo;t get into. It now occurs to me that this probably doesn&amp;rsquo;t work because &lt;code&gt;d3.zoomTransform(this.zoomG.node())&lt;/code&gt; was called at some point in the 100ms during which the smooth transition was occurring. Thus, the new &lt;code&gt;self.transform&lt;/code&gt; reflected the transform at some point along the transformation point rather than at &lt;code&gt;x=0, y=0, k=1&lt;/code&gt;.&lt;/span&gt; 
&lt;/p&gt;

&lt;h3 id=&#34;pan-ning:e218a3c29df923eed379019aa812cdd9&#34;&gt;&lt;code&gt;Pan&lt;/code&gt;ning&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;pan&lt;/code&gt; method will be triggered by a drag event. As with the &lt;code&gt;zoom&lt;/code&gt; method the basic idea will be to modify the &lt;code&gt;transform&lt;/code&gt; attribute of the zoom group element (line 9).&lt;/p&gt;

&lt;p&gt;What should the new &lt;code&gt;transform&lt;/code&gt; be? Among other things, the &lt;code&gt;d3.event&lt;/code&gt; object that is generated by a &lt;code&gt;drag&lt;/code&gt; event has properties&amp;ndash;&lt;code&gt;.dx&lt;/code&gt; and &lt;code&gt;.dy&lt;/code&gt;&amp;ndash;related to how much the mouse has moved in each direction since the last time the event was triggered. We know the initial &lt;code&gt;transform&lt;/code&gt; of the zoom group is from the &lt;code&gt;self.transform&lt;/code&gt; property. We can then update this property using &lt;code&gt;d3.event.dx&lt;/code&gt; and &lt;code&gt;d3.event.dy&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 1 &lt;/span&gt;SVGCanvas.prototype.makeZoomPan &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt;() {
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 2 &lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 3 &lt;/span&gt;  
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 4 &lt;/span&gt;  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; pan &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt;() {
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 5 &lt;/span&gt;    self.transform.x &lt;span style=&#34;color: #666666&#34;&gt;+=&lt;/span&gt; d3.event.dx;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 6 &lt;/span&gt;    self.transform.y &lt;span style=&#34;color: #666666&#34;&gt;+=&lt;/span&gt; d3.event.dy;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 7 &lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 8 &lt;/span&gt;    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Update Attribute&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 9 &lt;/span&gt;    d3.select(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;g.zoom-group&amp;#39;&lt;/span&gt;).attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;transform&amp;#39;&lt;/span&gt;, self.transform);
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;10 &lt;/span&gt;  }
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;11 &lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;12 &lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;13 &lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;14 &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h2 id=&#34;concluding-remarks:e218a3c29df923eed379019aa812cdd9&#34;&gt;Concluding Remarks&lt;/h2&gt;

&lt;p&gt;That&amp;rsquo;s it! To summarize, we&amp;rsquo;ve added panning and zooming to our still-rudimentary drawing app. The main ideas that I&amp;rsquo;ve introduced to do this were:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Routing methods to handle complex events (e.g. shift + drag).&lt;/li&gt;
&lt;li&gt;Selective &amp;ldquo;silencing&amp;rdquo; of event handlers associated with D3 events (e.g. zoom but don&amp;rsquo;t pan).&lt;/li&gt;
&lt;li&gt;Use of the &lt;code&gt;transform&lt;/code&gt; attribute of &lt;code&gt;svg&lt;/code&gt; elements.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In the next part we&amp;rsquo;ll make it possible to moving and resize rectangles that we&amp;rsquo;ve already created.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Drawing With D3.js Part 1: Rectangles</title>
      <link>https://michaelwooley.github.io/posts/drawing-1/</link>
      <pubDate>Wed, 06 Sep 2017 09:33:59 -0400</pubDate>
      
      <guid>https://michaelwooley.github.io/posts/drawing-1/</guid>
      <description>

&lt;p&gt;In this post I am going to take a first step towards a sort of drawing app with the &lt;code&gt;D3.js&lt;/code&gt; library. By the end of this post we&amp;rsquo;ll have a functioning-but-limited drawing app. In particular, we&amp;rsquo;ll be able to add rectangles to an svg canvas via a click-and-drag gesture.&lt;label for=&#34;point-of-this&#34; class=&#34;margin-toggle&#34;&gt;&amp;#8853;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;point-of-this&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;marginnote&#34;&gt;While there is a larger point to this little project, I&amp;rsquo;m not going to get into it right now. By the end of this series the purpose will come into focus.&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s what we&amp;rsquo;ll be working towards:&lt;/p&gt;

&lt;figure&gt;
&lt;label for=&#34;main-sample&#34; class=&#34;margin-toggle&#34;&gt;&amp;#8853;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;main-sample&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;marginnote&#34;&gt;Click and drag within the box to add a rectangle. See the full sample code at this  &lt;a href=&#34;https://gist.github.com/michaelwooley/b095fa7ce0e11d771dcb3f035fda1f07&#34;&gt;gist&lt;/a&gt;.&lt;/span&gt;
&lt;div class=&#34;sample-div&#34;&gt;&lt;/div&gt;
&lt;/figure&gt;


&lt;p&gt;There are going to be two main steps today. First, we&amp;rsquo;ll set up an object that will serve as our &amp;ldquo;canvas&amp;rdquo; going forward. Then, we&amp;rsquo;ll add some methods to the canvas to add the ability to add rectangles.&lt;/p&gt;

&lt;h2 id=&#34;the-svgcanvas-object:9d37e1981a24436f5fb50482f9491a95&#34;&gt;The &lt;code&gt;SVGCanvas&lt;/code&gt; Object&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s start out by making an object&amp;ndash;call it &lt;code&gt;SVGCanvas&lt;/code&gt;&amp;ndash;that will both make a &amp;ldquo;drawing canvas&amp;rdquo; and provide a foundation for adding additional functionality at a later point in time.&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;At the risk of introducing some ambiguity into the discussion, I will often speak of the &amp;ldquo;canvas&amp;rdquo; when discussing the object that will be drawn upon. However, be aware that this canvas will be SVG-based. I will not be using the HTML &lt;a href=&#34;https://www.w3schools.com/graphics/canvas_intro.asp&#34;&gt;Canvas element&lt;/a&gt; at all in what follows.&lt;/span&gt; 
&lt;/p&gt;

&lt;p&gt;To be precise, right now we&amp;rsquo;re going to make an object constructor. Here&amp;rsquo;s the starter code:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 1 &lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; SVGCanvas(options) {
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 2 &lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;/*&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 3 &lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;   *  An SVG-based drawing app.&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 4 &lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;   *  Input:&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 5 &lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;   *   - options: An object consisting of:&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 6 &lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;   *    - h: The height of the canvas (default: 250px).&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 7 &lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;   *    - w: The width of the canvas (default: 250px).&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 8 &lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;   *    - addTo: CSS Selector for element on which to add canvas (default: &amp;#39;body&amp;#39;).&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 9 &lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;   *    - addBorderRect: (bool) Add a border around the canvas (default: true).&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;10 &lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;   *  Returns: An SVG object contained in the `addTo` DOM element.&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;11 &lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;  */&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;12 &lt;/span&gt;  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; self &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;13 &lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Define the global SVG options&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;14 &lt;/span&gt;  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.options &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; options &lt;span style=&#34;color: #666666&#34;&gt;||&lt;/span&gt; {};
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;15 &lt;/span&gt;  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.options.h &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; options.h &lt;span style=&#34;color: #666666&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;250&lt;/span&gt;;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;16 &lt;/span&gt;  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.options.w &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; options.w &lt;span style=&#34;color: #666666&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;250&lt;/span&gt;;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;17 &lt;/span&gt;  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.options.addTo &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; options.addTo &lt;span style=&#34;color: #666666&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;body&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;18 &lt;/span&gt;  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.options.addBorderRect &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; options.addBorderRect &lt;span style=&#34;color: #666666&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;true&lt;/span&gt;;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;19 &lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;20 &lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Canvas&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;21 &lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//// Make the main container SVG&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;22 &lt;/span&gt;  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.svg &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; d3.select(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.options.addTo)
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;23 &lt;/span&gt;    .append(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;svg&amp;#39;&lt;/span&gt;)
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;24 &lt;/span&gt;    .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;height&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.options.h)
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;25 &lt;/span&gt;    .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;width&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.options.w)
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;26 &lt;/span&gt;    .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;class&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;display-svg&amp;#39;&lt;/span&gt;);
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;27 &lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//// Add border if requested&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;28 &lt;/span&gt;  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.options.addBorderRect) {
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;29 &lt;/span&gt;    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.svg.append(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;rect&amp;#39;&lt;/span&gt;)
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;30 &lt;/span&gt;      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;height&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.options.h)
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;31 &lt;/span&gt;      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;width&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.options.w)
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;32 &lt;/span&gt;      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;stroke&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;black&amp;#39;&lt;/span&gt;)
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;33 &lt;/span&gt;      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;stroke-width&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;4&lt;/span&gt;)
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;34 &lt;/span&gt;      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;opacity&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;0.25&lt;/span&gt;)
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;35 &lt;/span&gt;      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;fill-opacity&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;0.0&lt;/span&gt;)
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;36 &lt;/span&gt;      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;class&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;border-rect&amp;#39;&lt;/span&gt;);
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;37 &lt;/span&gt;  }
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;38 &lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;39 &lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// More to come...&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;40 &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;A lot of this is important-but-mundane boilerplate. The constructor takes as an argument an &lt;code&gt;options&lt;/code&gt; object, which specifies different options related to the dimensions and placement of the object in the DOM. A final option specifies whether a border should be added to the canvas, which helps users see where it is valid to draw.&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;If we just add an &lt;code&gt;&amp;lt;svg&amp;gt;&lt;/code&gt; element to the DOM and nothing else there will just be blank space.&lt;/span&gt; 
 That takes care of lines 1-18.&lt;/p&gt;

&lt;p&gt;The code beginning in line 22 creates the canvas in the form of an &lt;code&gt;&amp;lt;svg&amp;gt;&lt;/code&gt; element. This is also the first time that we&amp;rsquo;ve encountered D3 in the code.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;aside-basic-d3-js:9d37e1981a24436f5fb50482f9491a95&#34;&gt;Aside: Basic &lt;code&gt;D3.js&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;label for=&#34;d3-version&#34; class=&#34;margin-toggle&#34;&gt;&amp;#8853;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;d3-version&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;marginnote&#34;&gt;I will be using &lt;a href=&#34;https://github.com/d3/d3/wiki&#34;&gt;D3 v4.0&lt;/a&gt;. The API documentation can be found &lt;a href=&#34;https://github.com/d3/d3/blob/master/API.md&#34;&gt;here&lt;/a&gt;.&lt;/span&gt;
Here&amp;rsquo;s a quick run-down of the basic pattern that we follow when creating elements with d3:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; div &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; 			&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Define a variable in javascript called &amp;quot;div&amp;quot;&lt;/span&gt;
    d3.select(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;div.test&amp;#39;&lt;/span&gt;)	&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Select the first div element with class &amp;quot;test&amp;quot;.&lt;/span&gt;
				&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 	This element must already exist in the DOM.&lt;/span&gt;
    .append(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;div&amp;#39;&lt;/span&gt;)		&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Add/&amp;quot;append&amp;quot; a &amp;lt;div&amp;gt; element to the selected element&lt;/span&gt;
				&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 	This element is nested in the selected div.&lt;/span&gt;
    .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;class&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;container&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Add an attribute to the element.&lt;/span&gt;
				&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 	class=&amp;quot;container&amp;quot;&lt;/span&gt;
    .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;title&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;Test Div!&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Add another attribute: chain them on.&lt;/span&gt;
				&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 	title=&amp;quot;Test Div!&amp;quot;&lt;/span&gt;
    .style(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;float&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;left&amp;#39;&lt;/span&gt;)	&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Add inline styling to the element.&lt;/span&gt;
				&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 	style=&amp;quot;float: left&amp;quot;&lt;/span&gt;
    .style(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;position&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;fixed&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// You can also chain styling.&lt;/span&gt;
    ;				&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 	style=&amp;quot;float: left; position: fixed&amp;quot;&lt;/span&gt;

div.append(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;svg&amp;#39;&lt;/span&gt;);		&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Once we define a variable for the element we&lt;/span&gt;
				&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 	can skip the d3.select() step.&lt;/span&gt;
				&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Here we nest an &amp;lt;svg&amp;gt; element in the&lt;/span&gt;
				&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//	newly-created div. We could add more&lt;/span&gt;
				&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//	attributes and styling as above.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Suppose that our original HTML looked like this:
&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;div&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Once we run the above script it will look like this:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;container&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;title&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;Test Div!&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #7D9029&#34;&gt;style&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;float: left; position: fixed;&amp;quot;&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;svg&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;svg&lt;/span&gt;&amp;gt;
  &amp;lt;/&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;div&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;div&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;In short, D3.js provides an easy way of altering the DOM. There is a lot more to D3.js than this. However, this simple select-append pattern will turn out to be quite powerful.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;figure&gt;
&lt;label for=&#34;step-1&#34; class=&#34;margin-toggle&#34;&gt;&amp;#8853;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;step-1&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;marginnote&#34;&gt;
    &lt;div class=&#34;step-1&#34;&gt;&lt;/div&gt;
    Our canvas: a black-ish square that doesn&amp;rsquo;t do anything (yet).
&lt;/span&gt;
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;Returning to the &lt;code&gt;SVGCanvas&lt;/code&gt; constructor codeblock we can see that an svg element is appended to the DOM in lines 22-26. We define the parent element, height, and width using the options that were just defined. Lines 28-36 then append an svg &lt;code&gt;&amp;lt;rect&amp;gt;&lt;/code&gt; element to the SVG that was just created. This is our border.&lt;/p&gt;

&lt;p&gt;Okay, that&amp;rsquo;s it for the canvas. At this point we just have a black-ish square.&lt;/p&gt;

&lt;h2 id=&#34;adding-rectangles:9d37e1981a24436f5fb50482f9491a95&#34;&gt;Adding Rectangles&lt;/h2&gt;

&lt;p&gt;Now that we have our canvas in place we can start to add interactive elements. The first thing that we&amp;rsquo;re going to do is make it possible to create a rectangle via a click-and-drag gesture.&lt;/p&gt;

&lt;p&gt;To be specific, we want to implement the following behavior:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;When the user clicks (i.e. &lt;code&gt;mousedown&lt;/code&gt;/&lt;code&gt;start&lt;/code&gt;) on the svg element a &lt;code&gt;&amp;lt;rect&amp;gt;&lt;/code&gt;&lt;em&gt;-angle&lt;/em&gt; element is created in the svg.&lt;/li&gt;
&lt;li&gt;While the user is still holding down the mouse (i.e. &lt;code&gt;drag&lt;/code&gt;): Moving the mouse causes the rectangle to expand and contract. One corner of the rectangle remains at the point of the initial click while the opposite diagonal corner follows the mouse.&lt;/li&gt;
&lt;li&gt;When the user releases the click (i.e. &lt;code&gt;mouseup&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt;) the rectangle remains in place.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Luckily, D3 makes it fairly easy to do this sort of thing. Here is the plan: First, we&amp;rsquo;re going to create three methods corresponding to the three steps below. Then, we&amp;rsquo;re going to add a &lt;em&gt;drag event listener&lt;/em&gt; to the svg element that calls each of the three methods whenever the computer registers a click-and-drag gesture.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m going to work backwards through these two steps.&lt;/p&gt;

&lt;h3 id=&#34;drag-event-listener:9d37e1981a24436f5fb50482f9491a95&#34;&gt;Drag Event Listener&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;re going to alter the constructor for the &lt;code&gt;SVGCanvas&lt;/code&gt; element to add event listeners. This is another area where D3 excels. Here&amp;rsquo;s a snippet of the constructor code:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt; SVGCanvas(options) {
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...Previous code...&lt;/span&gt;

  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Rectangles&lt;/span&gt;
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//// Current Rectangle&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.Rect &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;r&amp;#39;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;null&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;x0&amp;#39;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;null&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;y0&amp;#39;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;null&lt;/span&gt;};
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//// Collection of all shapes&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.Shapes &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; [];

  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Actions/Listeners&lt;/span&gt;
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//// Methods for adding rectangles&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.makeAddRect();

  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// On drag: call addRect methods&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.svg.call(
    d3.drag()
    .on(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;start&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.addRect.start)
    .on(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;drag&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.addRect.drag)
    .on(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;end&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.addRect.end)
  );
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;In the first few lines I&amp;rsquo;ve added some code that will make more sense in a moment. For now, though, I want to focus on the line beginning with &lt;code&gt;this.svg.call(...)&lt;/code&gt;. Let&amp;rsquo;s walk through this.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;this.svg.call()&lt;/code&gt; invokes a &lt;a href=&#34;https://stackoverflow.com/questions/9596276/how-to-explain-callbacks-in-plain-english-how-are-they-different-from-calling-o&#34;&gt;callback function&lt;/a&gt; on the svg element that we just defined previously.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d3.drag()&lt;/code&gt; creates a new &lt;a href=&#34;https://github.com/d3/d3-drag&#34;&gt;drag behavior&lt;/a&gt;. Since it is nested in the &lt;code&gt;this.svg.call()&lt;/code&gt;, this behvior will be activated whenever the &lt;code&gt;this.svg&lt;/code&gt; is dragged.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.on(&#39;start&#39;, this.addRect.start)&lt;/code&gt; specifies what should happen when we, well, &lt;em&gt;start&lt;/em&gt; to drag the mouse on &lt;code&gt;this.svg&lt;/code&gt;. In particular, it says to invoke a function called &lt;code&gt;this.addRect.start&lt;/code&gt;, which we haven&amp;rsquo;t defined yet. Similarly, &lt;code&gt;.on(&#39;drag&#39;, this.addRect.drag)&lt;/code&gt; and &lt;code&gt;.on(&#39;end&#39;, this.addRect.end)&lt;/code&gt; specify what should happen as the mouse is dragged and at the end of the drag (i.e. when the mouse is released).&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;adding-the-addrect-methods:9d37e1981a24436f5fb50482f9491a95&#34;&gt;Adding the &lt;code&gt;addRect&lt;/code&gt; Methods&lt;/h3&gt;

&lt;p&gt;Now that we know how to add a dragging behavior to the canvas, we need to define the methods that are called at the &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;drag&lt;/code&gt;, and &lt;code&gt;end&lt;/code&gt; of the drag. To do this I&amp;rsquo;m going to define a prototype&amp;ndash;&lt;code&gt;makeAddRect&lt;/code&gt;&amp;ndash;which will append the methods to our &lt;code&gt;SVGCanvas&lt;/code&gt; object.&lt;/p&gt;

&lt;p&gt;Here is the code:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 1 &lt;/span&gt;SVGCanvas.prototype.mouseOffset &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt;() {
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 2 &lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Get the current location of mouse along with other info (to be added to later)&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 3 &lt;/span&gt;  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; m &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; d3.event;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 4 &lt;/span&gt;  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; m;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 5 &lt;/span&gt;}
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 6 &lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 7 &lt;/span&gt;SVGCanvas.prototype.makeAddRect &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt;() {
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 8 &lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Methods for adding rectangles to the svg.&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt; 9 &lt;/span&gt;  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; self &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;10 &lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;11 &lt;/span&gt;  start &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt;() {
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;12 &lt;/span&gt;    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//Add a rectangle&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;13 &lt;/span&gt;    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 1. Get mouse location in SVG&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;14 &lt;/span&gt;    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; m &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; self.mouseOffset();
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;15 &lt;/span&gt;    self.Rect.x0 &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; m.x;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;16 &lt;/span&gt;    self.Rect.y0 &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; m.y;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;17 &lt;/span&gt;    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 2. Make a rectangle&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;18 &lt;/span&gt;    self.Rect.r &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; self.svg &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//self.zoomG&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;19 &lt;/span&gt;      .append(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;g&amp;#39;&lt;/span&gt;)
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;20 &lt;/span&gt;      .append(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;rect&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// An SVG `rect` element&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;21 &lt;/span&gt;      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;x&amp;#39;&lt;/span&gt;, self.Rect.x0) &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Position at mouse location&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;22 &lt;/span&gt;      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;y&amp;#39;&lt;/span&gt;, self.Rect.y0)
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;23 &lt;/span&gt;      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;width&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Make it tiny&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;24 &lt;/span&gt;      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;height&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;)
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;25 &lt;/span&gt;      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;class&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;rect-main&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Assign a class for formatting purposes&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;26 &lt;/span&gt;    ;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;27 &lt;/span&gt;  }
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;28 &lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;29 &lt;/span&gt;  drag &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt;() {
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;30 &lt;/span&gt;    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// What to do when mouse is dragged&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;31 &lt;/span&gt;    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 1. Get the new mouse position&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;32 &lt;/span&gt;    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; m &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; self.mouseOffset();
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;33 &lt;/span&gt;    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 2. Update the attributes of the rectangle&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;34 &lt;/span&gt;    self.Rect.r.attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;x&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.min(self.Rect.x0, m.x))
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;35 &lt;/span&gt;      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;y&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.min(self.Rect.y0, m.y))
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;36 &lt;/span&gt;      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;width&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.abs(self.Rect.x0 &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; m.x))
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;37 &lt;/span&gt;      .attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;height&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #008000&#34;&gt;Math&lt;/span&gt;.abs(self.Rect.y0 &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; m.y));
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;38 &lt;/span&gt;  }
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;39 &lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;40 &lt;/span&gt;  end &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;function&lt;/span&gt;() {
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;41 &lt;/span&gt;    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// What to do on mouseup&lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;42 &lt;/span&gt;    self.Shapes.push(self.Rect);
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;43 &lt;/span&gt;  }
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;44 &lt;/span&gt;
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;45 &lt;/span&gt;  self.addRect &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; {start&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; start, drag&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; drag, end&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; end};
&lt;span style=&#34;background-color: #f0f0f0; padding: 0 5px 0 5px&#34;&gt;46 &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;In short, &lt;code&gt;.makeAddRect&lt;/code&gt; defines three functions then adds these functions to the &lt;code&gt;SVGCanvas&lt;/code&gt; object as an object/dictionary.&lt;/p&gt;

&lt;h3 id=&#34;what-to-do-at-the-beginning-of-a-drag-addrect-start:9d37e1981a24436f5fb50482f9491a95&#34;&gt;What to do at the beginning of a drag: &lt;code&gt;addRect.start&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;When we begin dragging we&amp;rsquo;re going to want to:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Record the initial position of the mouse.&lt;/li&gt;
&lt;li&gt;Add a &lt;code&gt;&amp;lt;rect&amp;gt;&lt;/code&gt; element within the svg.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This first step is carried out in lines 14-16. Line 14 calls a method called &lt;code&gt;mouseOffset&lt;/code&gt;, which returns the current (i.e. initial) position of the mouse.&lt;label for=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle sidenote-number&#34;&gt;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access positional params by string name&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;sidenote&#34;&gt;At this point &lt;code&gt;mouseOffset&lt;/code&gt; is overkill. However, it will come in handy once we begin zoom and pan the canvas.&lt;/span&gt; 

We then record these coordinates in the &lt;code&gt;self.Rect.x0&lt;/code&gt; and &lt;code&gt;self.Rect.y0&lt;/code&gt;. Recall that &lt;code&gt;self.Rect&lt;/code&gt; was defined in the constructor function. We will use &lt;code&gt;self.Rect&lt;/code&gt; to share variables between &lt;code&gt;addRect.start&lt;/code&gt;, &lt;code&gt;addRect.drag&lt;/code&gt;, and &lt;code&gt;addRect.end&lt;/code&gt; (and, eventually, other methods).&lt;/p&gt;

&lt;p&gt;Next, we make a tiny rectangle (line 18). We assign this object to &lt;code&gt;self.Rect.r&lt;/code&gt; so that we can modify it later. Notice that, before we append the &lt;code&gt;&amp;lt;rect&amp;gt;&lt;/code&gt; element, we append a &lt;code&gt;&amp;lt;g&amp;gt;&lt;/code&gt; (group) element to the svg. This nests the &lt;code&gt;&amp;lt;rect&amp;gt;&lt;/code&gt; in the &lt;code&gt;&amp;lt;g&amp;gt;&lt;/code&gt; element:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;svg&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;g&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;rect&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;rect&lt;/span&gt;&amp;gt;
  &amp;lt;/&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;g&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;svg&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;For what we&amp;rsquo;re doing right now, this isn&amp;rsquo;t necessary. However, it will come in handy later.&lt;/p&gt;

&lt;h3 id=&#34;what-to-do-while-dragging-addrect-drag:9d37e1981a24436f5fb50482f9491a95&#34;&gt;What to do while dragging: &lt;code&gt;addRect.drag&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Each time a drag event is registered we&amp;rsquo;re going to update the dimensions of the &lt;code&gt;&amp;lt;rect&amp;gt;&lt;/code&gt; that we just made to reflect the change in the mouse position. As with &lt;code&gt;addRect.start&lt;/code&gt; we begin by getting the current mouse position.&lt;/p&gt;

&lt;p&gt;We then modify the attributes the &lt;code&gt;&amp;lt;rect&amp;gt;&lt;/code&gt; element that we just created. Depending on where the mouse was dragged, the initial position could be any one of the four corners of the rectangle. We take account of this by comparing the current mouse position with the initial mouse position, which we saved in &lt;code&gt;self.Rect.x0&lt;/code&gt; and &lt;code&gt;self.Rect.y0&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;what-to-do-when-the-drag-is-complete-addrect-end:9d37e1981a24436f5fb50482f9491a95&#34;&gt;What to do when the drag is complete: &lt;code&gt;addRect.end&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;At the moment we don&amp;rsquo;t &lt;em&gt;have&lt;/em&gt; to do anything at the completion of the drag event. However, we will want to do some things eventually.&lt;/p&gt;

&lt;p&gt;For now, we add the current &lt;code&gt;self.Rect&lt;/code&gt; to the &lt;code&gt;self.Shapes&lt;/code&gt; array. By doing this we save the information about the rectangle for later. This could be useful because&amp;ndash;once a new drag event is initiated&amp;ndash;the information in &lt;code&gt;self.Rect&lt;/code&gt; will be overwritten with information about the newly-created rectangle.&lt;/p&gt;

&lt;h3 id=&#34;a-note-on-context-var-self-this:9d37e1981a24436f5fb50482f9491a95&#34;&gt;A Note on Context: &lt;code&gt;var self = this;&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Now I want to discuss line 9. What does this line do? It defines a variable, &lt;code&gt;self&lt;/code&gt;, which is equal to &lt;code&gt;this&lt;/code&gt;. Here, &lt;code&gt;this&lt;/code&gt; is the &lt;code&gt;SVGCanvas&lt;/code&gt; object. Thus, we can access all of the properties of the &lt;code&gt;SVGCanvas&lt;/code&gt; object via references to &lt;code&gt;self&lt;/code&gt;. Indeed, notice that in each of the three methods just defined we always used &lt;code&gt;self&lt;/code&gt; rather than &lt;code&gt;this&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Why do we need to do this? Go back to the line in the constructor where we defined the drag behavior:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.svg.call(
  d3.drag()
  .on(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;start&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.addRect.start)
  .on(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;drag&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.addRect.drag)
  .on(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;end&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;.addRect.end)
);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;In this snippet, &amp;ldquo;&lt;code&gt;this&lt;/code&gt;&amp;rdquo; refers to the &lt;code&gt;SVGCanvas&lt;/code&gt; object. This is because the line was executed in the context of the &lt;code&gt;SVGCanvas&lt;/code&gt; constructor. However, when &lt;code&gt;this.addRect.start&lt;/code&gt; is called the context will be different. In particular, &lt;code&gt;this.svg.call(...)&lt;/code&gt; defines a callback on the svg element, which means that the context is the svg element. Thus, if we were to reference &lt;code&gt;this&lt;/code&gt; within the &lt;code&gt;addRect.start&lt;/code&gt; method, we would be referring to the svg element rather than the &lt;code&gt;SVGCanvas&lt;/code&gt; object. Our attempts to reference &lt;code&gt;this.Rect.x0&lt;/code&gt; (for example) would result in an error because the svg object doesn&amp;rsquo;t have a &lt;code&gt;Rect&lt;/code&gt; property.&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;
&lt;label for=&#34;mutable-objects-demo&#34; class=&#34;margin-toggle&#34;&gt;&amp;#8853;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;mutable-objects-demo&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;marginnote&#34;&gt;
    &lt;img src=&#34;https://michaelwooley.github.io/posts/drawing-1/media/mutable_objects.gif&#34;&gt;
    Demo: mutable objects in javascript.
&lt;/span&gt;
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;By defining &lt;code&gt;var self = this;&lt;/code&gt; at the outset of &lt;code&gt;.makeAddRect&lt;/code&gt;, we set down a permanent reference to the &lt;code&gt;SVGCanvas&lt;/code&gt; object. Of course, this can only work if &lt;code&gt;self&lt;/code&gt; is mutable, which it is. That is, &lt;code&gt;self&lt;/code&gt; will mirror changes in &lt;code&gt;this&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To close this section I will note that I&amp;rsquo;m not a huge fan of this setup. My main complaint is that we need to be sure to call &lt;code&gt;this.makeAddRect();&lt;/code&gt; in the constructor function in the correct place. If anyone has a thought about how to smooth this out I&amp;rsquo;m all ears.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:9d37e1981a24436f5fb50482f9491a95&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Okay, that&amp;rsquo;s it. The full code for this post can be found at this &lt;a href=&#34;https://gist.github.com/michaelwooley/b095fa7ce0e11d771dcb3f035fda1f07&#34;&gt;gist&lt;/a&gt;. Obviously, this is a fairly rudimentary step. Going forward we&amp;rsquo;re going to want to think about:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Zooming and panning the canvas.&lt;/li&gt;
&lt;li&gt;Modifying the rectangles that we&amp;rsquo;ve added:

&lt;ul&gt;
&lt;li&gt;Resizing&lt;/li&gt;
&lt;li&gt;Repositioning&lt;/li&gt;
&lt;li&gt;Deleting&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Adding more information to the canvas:

&lt;ul&gt;
&lt;li&gt;Different types of rectangles.&lt;/li&gt;
&lt;li&gt;Extracting information from images.&lt;/li&gt;
&lt;li&gt;Downloading.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I will take up these threads in future posts.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://michaelwooley.github.io/pages/about/</link>
      <pubDate>Mon, 04 Sep 2017 15:06:08 -0400</pubDate>
      
      <guid>https://michaelwooley.github.io/pages/about/</guid>
      <description>

&lt;figure&gt;
&lt;label for=&#34;yrs-trly&#34; class=&#34;margin-toggle&#34;&gt;&amp;#8853;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;yrs-trly&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;marginnote&#34;&gt;
    &lt;img src=&#34;https://michaelwooley.github.io/images/mw_mug.JPG&#34;&gt;
    
&lt;/span&gt;
&lt;/figure&gt;


&lt;p&gt;Hello! My name is Michael Wooley. I am (as of January 2018) the senior economist at Grant Thornton. My current interests are in programming (broadly conceived), numerical problems, and ui design. However, I am always up for learning about something new. In a previous life I was an academic economist working on problems in macro, labor, and public economics.&lt;/p&gt;

&lt;p&gt;&lt;label for=&#34;error: cannot access named params by position&#34; class=&#34;margin-toggle&#34;&gt;&amp;#8853;&lt;/label&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;error: cannot access named params by position&#34; class=&#34;margin-toggle&#34;/&gt;
&lt;span class=&#34;marginnote&#34;&gt;&lt;i class=&#39;fa fa-envelope&#39;&gt;&lt;/i&gt;&amp;emsp;&lt;a href=&#34;mailto:wm.wooley@gmail.com&#34;&gt;wm.wooley@gmail.com&lt;/a&gt;&lt;br&gt;&lt;i class=&#39;fa fa-github&#39;&gt;&lt;/i&gt;&amp;emsp;&lt;a href=&#34;https://github.com/michaelwooley&#34;&gt;GitHub&lt;/a&gt;&lt;br&gt;&lt;i class=&#39;fa fa-linkedin&#39;&gt;&lt;/i&gt;&amp;emsp;&lt;a href=&#34;https://www.linkedin.com/in/michael-wooley/&#34;&gt;LinkedIn&lt;/a&gt;&lt;/span&gt;

Below you will find some links to my papers and projects. Please feel free to reach out to learn more.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://michaelwooley.github.io/files/resume/wooley_cv.pdf&#34;&gt;Here is my cv.&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;projects:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;Projects&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;yapij&lt;/code&gt;.&lt;/strong&gt; A lightweight python interpreter for Electron apps.

&lt;ul&gt;
&lt;li&gt;A single-process, multi-thread application that requires substantially less memory to run than Jupyter-Lab (20-40MB of ram compared to &amp;gt;100MB over several processes).&lt;/li&gt;
&lt;li&gt;Built-in magics to organize workspaces, handling of common python types (e.g. pandas dataframes) for easy use in node environment, ping-pong heartbeats.&lt;/li&gt;
&lt;li&gt;Besides node and python: Communication with ∅MQ, packing with MessagePack.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Understanding Busines Expectations.&lt;/strong&gt; (&lt;a href=&#34;https://michaelwooley.github.io/misc/ideation-site/&#34;&gt;demo site&lt;/a&gt;) Framework for eliciting subjective probability distributions in a survey context.

&lt;ul&gt;
&lt;li&gt;Provides new tool to ask questions regarding expectations/beliefs à la Manski [2005].&lt;/li&gt;
&lt;li&gt;Converts user drawing of curve into proper (but exact) piecewise-linear distribution. Realtime computation of summary statistics means that users know what their edits imply for, e.g., percentiles, mean, variance, etc.&lt;/li&gt;
&lt;li&gt;Set of questions to be explored in this context is large. The proposal section of the demo site discusses a few possible applications.&lt;/li&gt;
&lt;li&gt;Main tools: react, D3.js, redux, react-router.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GT Macro Modeling Framework.&lt;/strong&gt; Desktop app for modeling, forecasting, and viewing macroeconomic data.

&lt;ul&gt;
&lt;li&gt;Intuitive UI for use by non-programmers: model, variable, and data management; visualization of data, forecast diagnostics, forecasts.&lt;/li&gt;
&lt;li&gt;Numerical work (BVAR+Dynamic Factor Models, hierarchical hyperparameter selection, conditional forecasts) in python then connected to electron app via yapij (see above).&lt;/li&gt;
&lt;li&gt;Main tools: electron, react, python (NumPy, Numba, pandas).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/michaelwooley/gertlerKiyotaki2015&#34;&gt;&lt;strong&gt;Shooting Backwards&lt;/strong&gt;&lt;/a&gt; Developed novel solution to non-linear, non-stationary banking crisis model by Kiyotaki and Gertler (2015)

&lt;ul&gt;
&lt;li&gt;Time to solution cut 15x (relative to original paper)&lt;/li&gt;
&lt;li&gt;Used MATLAB symbolic algebra to demonstrate backwards-in-time solution a quartic polynomial with analytic solution (impossible with pen and paper)&lt;/li&gt;
&lt;li&gt;Used spline interpolation to infer solution to inner loop.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;selected-papers-and-presentations:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;Selected Papers and Presentations&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.dropbox.com/s/hqqqfgzoywaf6yo/coen_pirani_wooley_05_10_17.pdf?dl=0&#34;&gt;&amp;ldquo;Fiscal Centralization: Theory and Evidence from the Great Depression”&lt;/a&gt;, forthcoming. &lt;em&gt;American Economic Journal: Economic Policy&lt;/em&gt;. (with Daniele Coen-Pirani) [&lt;a href=&#34;https://www.aeaweb.org/articles?id=10.1257/pol.20150131&#34;&gt;Supplements&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://goo.gl/A6O6M9&#34;&gt;&amp;ldquo;Labor Market Consequences of Graduating During a Recession: The Case of the Termites”&lt;/a&gt;, 2017. [&lt;a href=&#34;https://goo.gl/FW1U4U&#34;&gt;Supplements&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.dropbox.com/s/cwv6w14pq56sg4q/macro_lunch_slides_1.pdf?dl=0&#34;&gt;&amp;ldquo;Monetary Policy in an Economy with Production Networks”&lt;/a&gt;, 2017. (Northwestern Macro Lunch)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://d-scholarship.pitt.edu/id/eprint/20564&#34;&gt;&amp;ldquo;State-Local Centralization During the Great Depression: A Case Study of Ohio”&lt;/a&gt;, 2013. [First Prize, 2013 Ossip Awards for Excellence in Undergraduate Writing. University of Pittsburgh.]&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://d-scholarship.pitt.edu/id/eprint/20565&#34;&gt;&amp;ldquo;Pitt and the Worker Rights Consortium: An Argument for Affiliation”&lt;/a&gt;, 2013. [On behalf of Pitt #NoSweat Coalition Against Sweatshop Labor]&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>